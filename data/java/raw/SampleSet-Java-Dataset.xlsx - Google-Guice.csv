Evaluator,Reviewer 1,Reviewer 2,Project,Class,Comment,comment length,summary,Exapnd,rational,deprecation,usage,exception,todo,Incomplete,Commented code,directive,formatter,License,Ownership,Pointer,Auto generated,Noise,Warnings,Recommendation,Precondition,Coding Guidelines,Extension,Subclass explnation,Observation
E3,,E4 (disagree),guice,SpiUtils.java,"
 * Utilities for testing the Multibinder & MapBinder extension SPI.
 *
 * @author sameb@google.com (Sam Berlin)
 | The kind of test we should perform. A live Injector, a raw Elements (Module) test, or both. | The kind of binding. | The result of the binding. ",5, Utilities for testing the Multibinder & MapBinder extension SPI.,| The kind of binding. | The result of the binding.,,,,,,,,,,,@author sameb@google.com (Sam Berlin),,,,," | The kind of test we should perform. A live Injector, a raw Elements (Module) test, or both. ",,,,,
E3,E1,,,DefaultMethodInterceptionTest.java,"
 * Tests for interception of default methods.
 *
 * @author cgdecker@google.com (Colin Decker)
 | Interface with a default method annotated to be intercepted. | Foo implementation that does not override the default method. | A base class defining a method with the same signature as Foo's default method. | Foo implementation that should use superclass method rather than default method. |
   * A base class defining an intercepted method with the same signature as Foo's default method.
   |
   * Foo implementation that should use intercepted superclass method rather than default method.",9, * Tests for interception of default methods.,,,, | Interface with a default method annotated to be intercepted. | Foo implementation that does not override the default method. | A base class defining a method with the same signature as Foo's default method. | Foo implementation that should use superclass method rather than default method. |,,,,,,,, * @author cgdecker@google.com (Colin Decker),,,,,"| Foo implementation that should use superclass method rather than default method. |
   * Foo implementation that should use intercepted superclass method rather than default method.",,,,"A base class defining a method with the same signature as Foo's default method. 
   * A base class defining an intercepted method with the same signature as Foo's default method.",
E1,,E4 (agree),,AbstractModule.java,"""* A support class for {@link Module}s which reduces repetition and results in a more readable
 * configuration. Simply extend this class, implement {@link #configure()}, and call the inherited
 * methods which mirror those found in {@link Binder}. For example:
 *
 * <pre>
 * public class MyModule extends AbstractModule {
 *   protected void configure() {
 *     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
 *     bind(CreditCardPaymentService.class);
 *     bind(PaymentService.class).to(CreditCardPaymentService.class);
 *     bindConstant().annotatedWith(Names.named(""port"")).to(8080);
 *   }
 * }
 * </pre>
 *
 * @author crazybob@google.com (Bob Lee)
 /**""",18,"""* A support class for {@link Module}s which reduces repetition and results in a more readable
  * configuration.",,,,"Simply extend this class, implement {@link #configure()}, and call the inherited
  * methods which mirror those found in {@link Binder}. For example:
  *
  * <pre>
  * public class MyModule extends AbstractModule {
  * protected void configure() {
  * bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
  * bind(CreditCardPaymentService.class);
  * bind(PaymentService.class).to(CreditCardPaymentService.class);
  * bindConstant().annotatedWith(Names.named(""port"")).to(8080);
  * }
  * }
  * </pre>",,,,,,,,* @author crazybob@google.com (Bob Lee),,,,,,,,,,
E1,,E4 (disagree),,Binder.java,"""* Collects configuration information (primarily <i>bindings</i>) which will be used to create an
 * {@link Injector}. Guice provides this object to your application's {@link Module} implementors so
 * they may each contribute their own bindings and other registrations.
 *
 * <h3>The Guice Binding EDSL</h3>
 *
 * Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you create bindings
 * simply and readably. This approach is great for overall usability, but it does come with a small
 * cost: <b>it is difficult to learn how to use the Binding EDSL by reading method-level
 * javadocs</b>. Instead, you should consult the series of examples below. To save space, these
 * examples omit the opening {@code binder}, just as you will if your module extends {@link
 * AbstractModule}.
 *
 * <pre>
 *     bind(ServiceImpl.class);</pre>
 *
 * This statement does essentially nothing; it ""binds the {@code ServiceImpl} class to itself"" and
 * does not change Guice's default behavior. You may still want to use this if you prefer your
 * {@link Module} class to serve as an explicit <i>manifest</i> for the services it provides. Also,
 * in rare cases, Guice may be unable to validate a binding at injector creation time unless it is
 * given explicitly.
 *
 * <pre>
 *     bind(Service.class).to(ServiceImpl.class);</pre>
 *
 * Specifies that a request for a {@code Service} instance with no binding annotations should be
 * treated as if it were a request for a {@code ServiceImpl} instance. This <i>overrides</i> the
 * function of any {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
 * annotations found on {@code Service}, since Guice will have already ""moved on"" to {@code
 * ServiceImpl} before it reaches the point when it starts looking for these annotations.
 *
 * <pre>
 *     bind(Service.class).toProvider(ServiceProvider.class);</pre>
 *
 * In this example, {@code ServiceProvider} must extend or implement {@code Provider<Service>}. This
 * binding specifies that Guice should resolve an unannotated injection request for {@code Service}
 * by first resolving an instance of {@code ServiceProvider} in the regular way, then calling {@link
 * Provider#get get()} on the resulting Provider instance to obtain the {@code Service} instance.
 *
 * <p>The {@link Provider} you use here does not have to be a ""factory""; that is, a provider which
 * always <i>creates</i> each instance it provides. However, this is generally a good practice to
 * follow. You can then use Guice's concept of {@link Scope scopes} to guide when creation should
 * happen -- ""letting Guice work for you"".
 *
 * <pre>
 *     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>
 *
 * Like the previous example, but only applies to injection requests that use the binding annotation
 * {@code @Red}. If your module also includes bindings for particular <i>values</i> of the
 * {@code @Red} annotation (see below), then this binding will serve as a ""catch-all"" for any values
 * of {@code @Red} that have no exact match in the bindings.
 *
 * <pre>
 *     bind(ServiceImpl.class).in(Singleton.class);
 *     // or, alternatively
 *     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>
 *
 * Either of these statements places the {@code ServiceImpl} class into singleton scope. Guice will
 * create only one instance of {@code ServiceImpl} and will reuse it for all injection requests of
 * this type. Note that it is still possible to bind another instance of {@code ServiceImpl} if the
 * second binding is qualified by an annotation as in the previous example. Guice is not overly
 * concerned with <i>preventing</i> you from creating multiple instances of your ""singletons"", only
 * with <i>enabling</i> your application to share only one instance if that's all you tell Guice you
 * need.
 *
 * <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that was specified with
 * an annotation on the {@code ServiceImpl} class.
 *
 * <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are servlet-specific scopes
 * available in {@code com.google.inject.servlet.ServletScopes}, and your Modules can contribute
 * their own custom scopes for use here as well.
 *
 * <pre>
 *     bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
 *         .to(CreditCardPaymentService.class);</pre>
 *
 * This admittedly odd construct is the way to bind a parameterized type. It tells Guice how to
 * honor an injection request for an element of type {@code PaymentService<CreditCard>}. The class
 * {@code CreditCardPaymentService} must implement the {@code PaymentService<CreditCard>} interface.
 * Guice cannot currently bind or inject a generic type, such as {@code Set<E>}; all type parameters
 * must be fully specified.
 *
 * <pre>
 *     bind(Service.class).toInstance(new ServiceImpl());
 *     // or, alternatively
 *     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>
 *
 * In this example, your module itself, <i>not Guice</i>, takes responsibility for obtaining a
 * {@code ServiceImpl} instance, then asks Guice to always use this single instance to fulfill all
 * {@code Service} injection requests. When the {@link Injector} is created, it will automatically
 * perform field and method injection for this instance, but any injectable constructor on {@code
 * ServiceImpl} is simply ignored. Note that using this approach results in ""eager loading"" behavior
 * that you can't control.
 *
 * <pre>
 *     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>
 *
 * Sets up a constant binding. Constant injections must always be annotated. When a constant
 * binding's value is a string, it is eligible for conversion to all primitive types, to {@link
 * Enum#valueOf(Class, String) all enums}, and to {@link Class#forName class literals}. Conversions
 * for other types can be configured using {@link #convertToTypes(Matcher, TypeConverter)
 * convertToTypes()}.
 *
 * <pre>
 *   {@literal @}Color(""red"") Color red; // A member variable (field)
 *    . . .
 *     red = MyModule.class.getDeclaredField(""red"").getAnnotation(Color.class);
 *     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>
 *
 * If your binding annotation has parameters you can apply different bindings to different specific
 * values of your annotation. Getting your hands on the right instance of the annotation is a bit of
 * a pain -- one approach, shown above, is to apply a prototype annotation to a field in your module
 * class, so that you can read this annotation instance and give it to Guice.
 *
 * <pre>
 *     bind(Service.class)
 *         .annotatedWith(Names.named(""blue""))
 *         .to(BlueService.class);</pre>
 *
 * Differentiating by names is a common enough use case that we provided a standard annotation,
 * {@link com.google.inject.name.Named @Named}. Because of Guice's library support, binding by name
 * is quite easier than in the arbitrary binding annotation case we just saw. However, remember that
 * these names will live in a single flat namespace with all the other names used in your
 * application.
 *
 * <pre>
 *     Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
 *     bind(ServiceImpl.class)
 *         .toConstructor(loneCtor);</pre>
 *
 * In this example, we directly tell Guice which constructor to use in a concrete class
 * implementation. It means that we do not need to place {@literal @}Inject on any of the
 * constructors and that Guice treats the provided constructor as though it were annotated so. It is
 * useful for cases where you cannot modify existing classes and is a bit simpler than using a
 * {@link Provider}.
 *
 * <p>The above list of examples is far from exhaustive. If you can think of how the concepts of one
 * example might coexist with the concepts from another, you can most likely weave the two together.
 * If the two concepts make no sense with each other, you most likely won't be able to do it. In a
 * few cases Guice will let something bogus slip by, and will then inform you of the problems at
 * runtime, as soon as you try to create your Injector.
 *
 * <p>The other methods of Binder such as {@link #bindScope}, {@link #bindInterceptor}, {@link
 * #install}, {@link #requestStaticInjection}, {@link #addError} and {@link #currentStage} are not
 * part of the Binding EDSL; you can learn how to use these in the usual way, from the method
 * documentation.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 * @author kevinb@google.com (Kevin Bourrillion)
 /**""",152,"""* Collects configuration information (primarily <i>bindings</i>) which will be used to create an
  * {@link Injector}. Guice provides this object to your application's {@link Module} implementors so
  * they may each contribute their own bindings and other registrations.",,,,"* <h3>The Guice Binding EDSL</h3>
  *
  * Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you create bindings
  * simply and readably. This approach is great for overall usability, but it does come with a small
  * cost: <b>it is difficult to learn how to use the Binding EDSL by reading method-level
  * javadocs</b>. Instead, you should consult the series of examples below. To save space, these
  * examples omit the opening {@code binder}, just as you will if your module extends {@link
  * AbstractModule}.
  *
  * <pre>
  * bind(ServiceImpl.class);</pre>
  *
  * This statement does essentially nothing; it ""binds the {@code ServiceImpl} class to itself"" and
  * does not change Guice's default behavior. You may still want to use this if you prefer your
  * {@link Module} class to serve as an explicit <i>manifest</i> for the services it provides. Also,
  * in rare cases, Guice may be unable to validate a binding at injector creation time unless it is
  * given explicitly.
  *
  * <pre>
  * bind(Service.class).to(ServiceImpl.class);</pre>
  *
  * Specifies that a request for a {@code Service} instance with no binding annotations should be
  * treated as if it were a request for a {@code ServiceImpl} instance. This <i>overrides</i> the
  * function of any {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
  * annotations found on {@code Service}, since Guice will have already ""moved on"" to {@code
  * ServiceImpl} before it reaches the point when it starts looking for these annotations.
  *
  * <pre>
  * bind(Service.class).toProvider(ServiceProvider.class);</pre>
  *
  * In this example, {@code ServiceProvider} must extend or implement {@code Provider<Service>}. This
  * binding specifies that Guice should resolve an unannotated injection request for {@code Service}
  * by first resolving an instance of {@code ServiceProvider} in the regular way, then calling {@link
  * Provider#get get()} on the resulting Provider instance to obtain the {@code Service} instance.
  *
  * <p>The {@link Provider} you use here does not have to be a ""factory""; that is, a provider which
  * always <i>creates</i> each instance it provides. However, this is generally a good practice to
  * follow. You can then use Guice's concept of {@link Scope scopes} to guide when creation should
  * happen -- ""letting Guice work for you"".
  *
  * <pre>
  * bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>
  *
  * Like the previous example, but only applies to injection requests that use the binding annotation
  * {@code @Red}. If your module also includes bindings for particular <i>values</i> of the
  * {@code @Red} annotation (see below), then this binding will serve as a ""catch-all"" for any values
  * of {@code @Red} that have no exact match in the bindings.
  *
  * <pre>
  * bind(ServiceImpl.class).in(Singleton.class);
  * // or, alternatively
  * bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>
  *
  * Either of these statements places the {@code ServiceImpl} class into singleton scope. Guice will
  * create only one instance of {@code ServiceImpl} and will reuse it for all injection requests of
  * this type. Note that it is still possible to bind another instance of {@code ServiceImpl} if the
  * second binding is qualified by an annotation as in the previous example. Guice is not overly
  * concerned with <i>preventing</i> you from creating multiple instances of your ""singletons"", only
  * with <i>enabling</i> your application to share only one instance if that's all you tell Guice you
  * need.
  *
  * <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that was specified with
  * an annotation on the {@code ServiceImpl} class.
  *
  * <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are servlet-specific scopes
  * available in {@code com.google.inject.servlet.ServletScopes}, and your Modules can contribute
  * their own custom scopes for use here as well.
  *
  * <pre>
  * bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
  * .to(CreditCardPaymentService.class);</pre>
  *
  * This admittedly odd construct is the way to bind a parameterized type. It tells Guice how to
  * honor an injection request for an element of type {@code PaymentService<CreditCard>}. The class
  * {@code CreditCardPaymentService} must implement the {@code PaymentService<CreditCard>} interface.
  * Guice cannot currently bind or inject a generic type, such as {@code Set<E>}; all type parameters
  * must be fully specified.
  *
  * <pre>
  * bind(Service.class).toInstance(new ServiceImpl());
  * // or, alternatively
  * bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>
  *
  * In this example, your module itself, <i>not Guice</i>, takes responsibility for obtaining a
  * {@code ServiceImpl} instance, then asks Guice to always use this single instance to fulfill all
  * {@code Service} injection requests. When the {@link Injector} is created, it will automatically
  * perform field and method injection for this instance, but any injectable constructor on {@code
  * ServiceImpl} is simply ignored. Note that using this approach results in ""eager loading"" behavior
  * that you can't control.
  *
  * <pre>
  * bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>
  *
  * Sets up a constant binding. Constant injections must always be annotated. When a constant
  * binding's value is a string, it is eligible for conversion to all primitive types, to {@link
  * Enum#valueOf(Class, String) all enums}, and to {@link Class#forName class literals}. Conversions
  * for other types can be configured using {@link #convertToTypes(Matcher, TypeConverter)
  * convertToTypes()}.
  *
  * <pre>
  * {@literal @}Color(""red"") Color red; // A member variable (field)
  * . . .
  * red = MyModule.class.getDeclaredField(""red"").getAnnotation(Color.class);
  * bind(Service.class).annotatedWith(red).to(RedService.class);</pre>
  *
  * If your binding annotation has parameters you can apply different bindings to different specific
  * values of your annotation. Getting your hands on the right instance of the annotation is a bit of
  * a pain -- one approach, shown above, is to apply a prototype annotation to a field in your module
  * class, so that you can read this annotation instance and give it to Guice.
  *
  * <pre>
  * bind(Service.class)
  * .annotatedWith(Names.named(""blue""))
  * .to(BlueService.class);</pre>
  *
  * Differentiating by names is a common enough use case that we provided a standard annotation,
  * {@link com.google.inject.name.Named @Named}. Because of Guice's library support, binding by name
  * is quite easier than in the arbitrary binding annotation case we just saw. However, remember that
  * these names will live in a single flat namespace with all the other names used in your
  * application.
  *
  * <pre>
  * Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
  * bind(ServiceImpl.class)
  * .toConstructor(loneCtor);</pre>
  *
  * In this example, we directly tell Guice which constructor to use in a concrete class
  * implementation. It means that we do not need to place {@literal @}Inject on any of the
  * constructors and that Guice treats the provided constructor as though it were annotated so. It is
  * useful for cases where you cannot modify existing classes and is a bit simpler than using a
  * {@link Provider}.
  *
  * <p>The above list of examples is far from exhaustive. If you can think of how the concepts of one
  * example might coexist with the concepts from another, you can most likely weave the two together.
  * If the two concepts make no sense with each other, you most likely won't be able to do it. In a
  * few cases Guice will let something bogus slip by, and will then inform you of the problems at
  * runtime, as soon as you try to create your Injector.
  *
  * <p>The other methods of Binder such as {@link #bindScope}, {@link #bindInterceptor}, {@link
  * #install}, {@link #requestStaticInjection}, {@link #addError} and {@link #currentStage} are not
  * part of the Binding EDSL; you can learn how to use these in the usual way, from the method
  * documentation.
  *
  /**""",,,,,,,,"* @author crazybob@google.com (Bob Lee)
  * @author jessewilson@google.com (Jesse Wilson)
  * @author kevinb@google.com (Kevin Bourrillion)",,,,,,,,,,
E1,,E4 (agree),,EncounterImpl.java, @author jessewilson@google.com (Jesse Wilson) ,1,,,,,,,,,,,,,@author jessewilson@google.com (Jesse Wilson),,,,,,,,,,
E1,,E4 (agree),,ImplicitBindingTest.java," @author crazybob@google.com (Bob Lee) | An enum cannot be implemented by anything, so it should not be possible to have a successful| Valid JITable binding",1,,,"An enum cannot be implemented by anything, so it should not be possible to have a successful| Valid JITable binding",,,,,,,,,,@author crazybob@google.com (Bob Lee),,,,,,,,,,
E1,,E4 (agree),,ProxyFactoryTest.java, @author crazybob@google.com (Bob Lee) ,1,,,,,,,,,,,,,@author crazybob@google.com (Bob Lee),,,,,,,,,,
E1,,E4 (agree),,PrivateElementProcessor,"
 * Handles {@code Binder.newPrivateBinder()} elements.
 *
 * @author jessewilson@google.com (Jesse Wilson)",5,* Handles {@code Binder.newPrivateBinder()} elements.,,,,,,,,,,,,@author jessewilson@google.com (Jesse Wilson),,,,,,,,,,
E1,,E4 (agree),,ManagedFilterPipeline.java,"
 * Central routing/dispatch class handles lifecycle of managed filters, and delegates to the servlet
 * pipeline.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)",6,"* Central routing/dispatch class handles lifecycle of managed filters, and delegates to the servlet
  * pipeline.",,,,,,,,,,,,@author dhanji@gmail.com (Dhanji R. Prasanna),,,,,,,,,,
E1,,E4 (agree),,Element.java," * An internal binding annotation applied to each element in a multibinding. All elements are
 * assigned a globally-unique id to allow different modules to contribute multibindings
 * independently.
 *
 * @author jessewilson@google.com (Jesse Wilson)",7,* An internal binding annotation applied to each element in a multibinding,"All elements are
  * assigned a globally-unique id to allow different modules to contribute multibindings
  * independently.",,,,,,,,,,,@author jessewilson@google.com (Jesse Wilson),,,,,,,,,,