Evaluator,Reviewer,Reviewer 2,class,Comment,Comment size,Intent,Responsibilities,Collaborators,Key messages,Key implementation points,Instance variables,ReferenceToOtherResources,Subclasses Explanation,Class references,Example,Todo comments,Coding guidlines,Warnings,Discourse,Links,Extensions,Recommendations,Observations,Preconditions,Dependencies,License/copyright ,Other
E1,E2 (Agree),,GtSnippetRequest,I am sent by snippet widget looks when they request to receive a snippet model from the widget model,1,I am sent by snippet widget looks when they request to receive a snippet model from the widget model,I am sent by snippet widget looks when they request to receive a snippet model from the widget model,,,,,,,,,,,,,,,,,,,,
E1,E2 (Agree),,BrPagerPagePreviewResizeListener,I update the size of a page preview element in a scroll bar according to the size of a corresponding page,1,,I update the size of a page preview element in a scroll bar according to the size of a corresponding page,,,,,,,,,,,,,,,,,,,,
E1,E2 (Agree),,BlExampleCustomEventTarget,I am an example of a custom non-element event target that can be nicely integrated in bloc infrastructure,1,I am an example of a custom non-element event target, that can be nicely integrated in bloc infrastructure,,,,,,,,,,,,,,,,,,,,
E1,E2 (disagree),E3 (agree with E2),BrTabAddedEvent,I am sent when a new tab is added to ${class:BrTabGroupModel},1,,I am sent when a new tab is added to ${class:BrTabGroupModel},I am sent when a new tab is added to ${class:BrTabGroupModel},,,,,,${class:BrTabGroupModel},,,,,,,,,,,,,
E1,E2 (Agree),,BlUniverseEventsCleared,Emitted when all of the event loop's events have been processed and control flow is about to be taken away from the Universe.,1,,Emitted when all of the event loop's events have been processed and control flow is about to be taken away from the Universe.,,,,,,,,,,,,,,,,,Emitted when all of the event loop's events have been processed and control flow is about to be taken away from the Universe.,,,
E1,E2 (disagree),E3 (agree with E2),BlGeometryAnchorMoved,I am sent when anchor's position changed,1,,I am sent when anchor's position changed,,,,,,,,,,,,,,,,,,,,
E1,E2 (Agree),,GlutinResumedEvent,Emitted when the application has been resumed.,1,,Emitted when the application has been resumed.,,,,,,,,,,,,,,,,,Emitted when the application has been resumed.,,,
E1,E2 (Agree),,BlLocalImageCacheTest,This class contains tests,1,,This class contains tests,,,,,,,,,,,,,,,,,,,,
E1,E2 (Agree),,TSpFontDescriptor,"I am a helper trait that defines basic font properties such as weight, style and stretch",1,I am a helper trait ,"that defines basic font properties such as weight, style and stretch",,,,,,,,,,,,,,,,,,,,
E1,E2 (Agree),,BrTextEditorCursorElementRemovedEvent,I am sent by the text editor element when an element playing a role of the cursor is removed from the editor,1,I am sent by the text editor element,I am sent by the text editor element when an element playing a role of the cursor is removed from the editor,,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),GtRlNode,I am an abstraction for a type of dependency in the loading configuration of a system.,1,I am an abstraction for a type of dependency in the loading configuration of a system.,I am an abstraction for a type of dependency in the loading configuration of a system.,,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),GtDiagrammerDummyTool,I am a dummy tool that does nothing,1,I am a dummy tool, that does nothing,,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BlMouseMiddleButton,I am a middle mouse button. Often can be triggered by mouse wheel click,1,I am a middle mouse button.,Often can be triggered by mouse wheel clic,,,,,,,,,,,,,,,,,,,,
E1,,E3 (disagree),BlInfiniteExampleClassesDataSource,I am a data source of the collection of all classes in the image,1,I am a data source of the collection of all classes in the image,,I am a data source of the collection of all classes in the image,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BlExampleElementWithBrokenOnLayout,I am an element with a broken onLayout method that throws Error (SubscriptOutOfBounds),1,I am an element with a broken onLayout method ,that throws Error (SubscriptOutOfBounds),,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BlAnchorRelativeToElement,Relative anchor takes an arbitrary element as a reference an compute its position based on properties of that element.,1,,Relative anchor takes an arbitrary element as a reference an compute its position based on properties of that element.,,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BrLook,I define how widgets look. In addition to the BrViewModel I listen to UI events and update decoration (non meaningful) elements of the widgets,1,,I define how widgets look. In addition to the BrViewModel I listen to UI events and update decoration (non meaningful) elements of the widgets, In addition to the BrViewModel I listen to UI events and update decoration (non meaningful) elements of the widgets,,,,,,BrViewModel,,,,,,,,,,,,,
E1,,E3 (agree),BlElementPositionChangeTest,I contain examples of position change logging functionality,1,,I contain examples of position change logging functionality,,,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),GtLibraryInstallerMorph,Top most container of the whole installer,1,Top most container of the whole installer,,,,,,,,,,,,,,,,,,,,,
E1,,E3 (disagree),GtGraphTreemapLayoutConstraints,I am a ${class:BlLayoutConstraints}$ for ${class:GtGraphTreemapSquarifiedLayout}$ layout.,1,I am a ${class:BlLayoutConstraints}$ for ${class:GtGraphTreemapSquarifiedLayout}$ layout.,,I am a ${class:BlLayoutConstraints}$ for ${class:GtGraphTreemapSquarifiedLayout}$ layout.,,,,,, ${class:BlLayoutConstraints}$ for ${class:GtGraphTreemapSquarifiedLayout}$,,,,,,,,,,,,,
E2,,E1 (disagree),BlKeyCombinationConverterCNF,I transform composite key combination formula into a CNF (https://en.wikipedia.org/wiki/Conjunctive_normal_form),1,,I transform composite key combination formula into a CNF (https://en.wikipedia.org/wiki/Conjunctive_normal_form),,I transform composite key combination formula into a CNF (https://en.wikipedia.org/wiki/Conjunctive_normal_form),,,I transform composite key combination formula into a CNF (https://en.wikipedia.org/wiki/Conjunctive_normal_form),,,,,,,,(https://en.wikipedia.org/wiki/Conjunctive_normal_form),,,,,,,
E2,,E1 (agree),BlCompulsoryCombinationTest,This class contains tests,1,,This class contains tests,,,,,,,,,,,,,,,,,,,,
E2,,E1 (agree),SpUserFontSource,I represent a font face source and know how to retrieve font contents from it,1,I represent a font face source ,and know how to retrieve font contents from it,,,,,,,,,,,,,,,,,,,,
E2,,E1 (disagree),BlArrowheadExamples,I contain examples of different types of ==BlArrowheadElement==,1,,I contain examples of different types of ==BlArrowheadElement==,,,,,,,BlArrowheadElement,,,,,,,,,,,,,
E2,,E1 (agree),BlChickenLeg,I am a single red chicken leg with two toes,1,I am a single red chicken leg with two toes,,,,,,,,,,,,,,,,,,,,,
E2,,E1 (agree),BlGeometryElement,I am a root class of geometry elements - elements driven by geometry anchors.,1,I am a root class of geometry elements,I am a root class of geometry elements - elements driven by geometry anchors.,,,,,,,,,,,,,,,,,,,,
E2,,E1 (agree),GtDiagrammerStarStencil,I create a star element,1,,I create a star element,,,,,,,,,,,,,,,,,,,,
E2,,E1 (disagree),BrSelectionRequest,I am sent by a look to request selection update from the view model,1,,I am sent by a look to request selection update from the view model,,,,,,,,,,,,,,,,,,,,
E2,,E1 (agree),BlSelection,I represent a text selection defined as interval [from...to],1,I represent a text selection defined as interval [from...to],,,,,,,,,,,,,,,,,,,,,
E2,,E1 (disagree),BrMaterialToggleBackgroundLook,I describe how background of a material toggle button changes due to toggle events,1,,I describe how background of a material toggle button changes due to toggle events,,,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),SkiaFilterSourceCanvas,When canvas is a source of a filter we should take its snapshot,1,,,,,,,,,,,,,,,,,,When canvas is a source of a filter we should take its snapshot,,,,
E2,,E3 (agree),GtABAddress,I hold all data relevant for an address,1,,I hold all data relevant for an address,,,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BrExampleColoredElementStencil,I am an example of a custom Stencil that creates a rounded rectangular element with cusomizable background color and corner radius,1,I am an example of a custom Stencil ,that creates a rounded rectangular element with cusomizable background color and corner radius,,that creates a rounded rectangular element with cusomizable background color and corner radius,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BlSpaceEventExamples,I contain examples of space related events,1,,I contain examples of space related events,,,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BlGeometryAnchorListener,I am an event listener that listens Anchor Moved event send by Anchor,1,I am an event listener that listens Anchor Moved event send by Anchor,I am an event listener that listens Anchor Moved event send by Anchor,I am an event listener that listens Anchor Moved event send by Anchor,,,,,,,,,,,,,,,,,,,
E2,,E3 (disagree),BlElementPositionChangeTest,I contain examples of position change logging functionality,1,,I contain examples of position change logging functionality,,,,,,,,,,,,,,,,,,,,
E2,,E3 (disagree),GtConnectorButtonAddedEvent,Is sent after button is added to the scene graph,1,,Is sent after button is added to the scene graph,,,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BrTextEditorSelectionUpdateCommand,I do the hard job of visually updating selection by requesting segment holders to partially update themselves,1,,I do the hard job of visually updating selection by requesting segment holders to partially update themselves,,I do the hard job of visually updating selection by requesting segment holders to partially update themselves,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BlMorphicSpaceHostMorph,I act as a space host for a Bloc space,1,I act as a space host for a Bloc space,,I act as a space host for a Bloc space,,,,,,,,,,,,,,,,,,,
E2,,E3 (disagree),BrTextEditorLineSplitter,I split a piece of text into line segments ${class:BrTextEditorLineSegment}$,1,,I split a piece of text into line segments ${class:BrTextEditorLineSegment}$,,,,,,,${class:BrTextEditorLineSegment}$,,,,,,,,,,,,,
E3,E2 (agree),,BlElementCenterLeftAnchor,My position is equal to the left center of a reference element,1,,My position is equal to the left center of a reference element,My position is equal to the left center of a reference element,,,,,,,,,,,,,,,,,,,
E3,E2 (agree),,BlHeadlessHost,I am a fallback host that is chosen if there are no other available and supported hosts.,1,I am a fallback host that is chosen if there are no other available and supported hosts.,I am a fallback host that is chosen if there are no other available and supported hosts.,,,,,,,,,,,,,,,,,I am a fallback host that is chosen if there are no other available and supported hosts.,,,
E3,E2 (agree),,BlMorphicWindowHost,I am a concrete implementation of a BlHost that allows users to open host bloc spaces within Moprhic windows,1,I am a concrete implementation of a BlHost,that allows users to open host bloc spaces within Moprhic windows,that allows users to open host bloc spaces within Moprhic windows,,,,,,BlHost,,,,,,,,,,,,,
E3,E2 (agree),,BlElementBoundsExamples,I contain examples of element bounds api,1,,I contain examples of element bounds api,,,,,,,,,,,,,,,,,,,,
E3,E2 (agree),,BrInteractiveModel,"I am a composite interaction model responsible for managing widget state such as pressed, hovered, focused.",1,"I am a composite interaction model responsible for managing widget state such as pressed, hovered, focused.","I am a composite interaction model responsible for managing widget state such as pressed, hovered, focused.","I am a composite interaction model responsible for managing widget state such as pressed, hovered, focused.",,,,,,,,,,,,,,,,,,,
E3,E2 (agree),,BlMorphicWindowOpenedEvent,I am fired by morphic host window when it is opened in the World,1,I am fired by morphic host window when it is opened in the World,,I am fired by morphic host window when it is opened in the World,,,,,,World,,,,,,,,,,,,,
E3,E2 (agree),,BlUniverseEvent,I am an event that is sent to the universe by the host to control the Universe's lifecycle,1,I am an event that is sent to the universe by the host to control the Universe's lifecycle,,I am an event that is sent to the universe by the host to control the Universe's lifecycle,,,,,,Universe,,,,,,,,,,,,,
E3,E2 (agree),,GtDiagrammerArrowheadFilledTriangleStencil,I create a filled triangle arrowhead,1,,I create a filled triangle arrowhead,,,,,,,,,,,,,,,,,,,,
E3,E2 (agree),,BrPagerPageResizerElement,I am the element with which a pager page can be resized horizontally.,1,I am the element with which a pager page can be resized horizontally.,,I am the element with which a pager page can be resized horizontally.,,,,,,,,,,,,,,,,,,,
E3,E2 (agree),,GtExampleInstanceSubject,I indicate that the subject of an example is an object. I am the default subject of an example. Other kinds of subjects should be used to inducate a particular type of object like a class or method.,1,I am the default subject of an example.,I indicate that the subject of an example is an object., I am the default subject of an example.,,,,, Other kinds of subjects should be used to inducate a particular type of object like a class or method.,,,,,,,,,,,,,,
E3,,E1 (agree),GtGraphEdgesIterator,I am an abstract iterator over edges connected to a graph element,1,I am an abstract iterator over edges connected to a graph element,,I am an abstract iterator over edges connected to a graph element,,,,,,,,,,,,,,,,,,,
E3,,E1 (disagree),BlInfiniteSmoothScrollerAction,I hold information about a smooth scroll request by a SmoothScroller.,1,,I hold information about a smooth scroll request by a SmoothScroller.,I hold information about a smooth scroll request by a SmoothScroller.,,,,,,SmoothScroller,,,,,,,,,,,,,
E3,,E1 (agree),GtDiagrammerArrowheadFilledCircleStencil,I create a filled circle arrow head with the border and background equal to the color of the curve,1,,I create a filled circle arrow head with the border and background equal to the color of the curve,,,,,,,,,,,,,,,,,,,,
E3,,E1 (agree),BlMatrixTransformation,I am an affine transformation that is directly defined by transformation matrix,1,I am an affine transformation that is directly defined by transformation matrix,,,,,,,,,,,,,,,,,,,,,
E3,,E1 (disagree),GtDiagrammerArrowheadNoneStencil,I am used to remove arrow heads,1,,I am used to remove arrow heads,,,,,,,,,,,,,,,,,,,,
E3,,E1 (agree),Gt4XMLHighlightedToken,This class stores a highlight TextColor and 1-based start/end highlight positions.,1,,This class stores a highlight TextColor and 1-based start/end highlight positions.,,,1-based start/end highlight positions.,,,,TextColor,,,,,,,,,,,,,
E3,,E1 (disagree),BrTextEditorLetterInputFilter,I only allow letters,1,,I only allow letters,,,,,,,,,,,I only allow letters,,,,,,,,,
E3,,E1 (agree),BlConcatenationRopeIterator,I am a special iterator used to iterate over concatenation rope,1,I am a special iterator used to iterate over concatenation rope,I am a special iterator used to iterate over concatenation rope,I am a special iterator used to iterate over concatenation rope,,,,,,,,,,,,,,,,,,,
E3,,E1 (agree),GtDiagrammerEllipseStencil,I create an ellipse element,1,,I create an ellipse element,,,,,,,,,,,,,,,,,,,,
E3,,E1 (disagree),BlGeometry,The geometry is used to define the geometry to be drawn and the interaction area.,1,,The geometry is used to define the geometry to be drawn and the interaction area.,The geometry is used to define the geometry to be drawn and the interaction area.,,,,,,,,,,,,,,,,,,,
E1,E2 (agree),,BlVisibilityHidden,"I am a concrete visibility type - ""hidden"".
Once set, element should not be rendered but should participate in layout and take space.",2,"I am a concrete visibility type - ""hidden"".",,,,,,,,,,,,"Once set, element should not be rendered but should participate in layout and take space.",,,,"Once set, element should not be rendered but should participate in layout and take space.",,,,,
E1,E2 (agree),,GtSnippetElementHolder,"I hold a snippet element within an infinite list element.
I know my unique snippet type (pharo code, url, empty etc)",2,,"I hold a snippet element within an infinite list element.I know my unique snippet type (pharo code, url, empty etc)",,,,,,,,,,,,,,,,,,,,
E1,E2 (agree),,BlInfiniteItemAnimationsFinished,"I am sent when all pending or running animations in an ItemAnimator are finished.
I can be used, for example, to delay an action in a data set until currently-running animations are complete.",2,,"I can be used, for example, to delay an action in a data set until currently-running animations are complete.",,,,,,,,,,,,,,,,,I am sent when all pending or running animations in an ItemAnimator are finished.,,,
E1,E2 (agree),,TBlEventTarget,"I implement a basic infrastructure of event management.
Any object that needs to be able to handle events should use me.",2,,I implement a basic infrastructure of event management.,,,,,,,,,,,,,,,Any object that needs to be able to handle events should use me.,,,,,
E1,E2 (disagree),,TSpartaStrokeOptions,"I define an api of stroke options object.
Stroke options are used in stroking operations.",2,,"I define an api of stroke options object.
Stroke options are used in stroking operations.",,"I define an api of stroke options object.
Stroke options are used in stroking operations.",,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BlMeasurementUnspecifiedMode,"I represent a concrete implementation of ""unspecified"" measurement mode.
For more information see class comment of BlMeasurementMode",2,"I represent a concrete implementation of ""unspecified"" measurement mode.",,,,,,For more information see class comment of BlMeasurementMode,,BlMeasurementMode,,,,,,,,,,,,,
E1,E2 (agree with E3),E3 (disagree),BrTextEditorSelectionRecorder,"I am used to record text selection intervals while user drags mouse over the text editor.
Additionally I play a role of a selection strategy to support single or multiple selection.",2,,"I am used to record text selection intervals while user drags mouse over the text editor.
Additionally I play a role of a selection strategy to support single or multiple selection.","I am used to record text selection intervals while user drags mouse over the text editor.
Additionally I play a role of a selection strategy to support single or multiple selection.",,,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BlDragDelegate,"Drag delegate provides drag items when a visual element lifts.
Drag gesture fails if there are no drag items",2,,"Drag delegate provides drag items when a visual element lifts.
Drag gesture fails if there are no drag items",,,,,,,,,,,,,,,,,,,,
E1,,E3 (disagree),SpUserFontSourceBuffer,"I am a buffer source.
Is useful if font is stored as byte array in the image",2,I am a buffer source.,,,,,,,,,,,,,,,,Is useful if font is stored as byte array in the image,,,,,
E1,,E3 (agree),BlScalableFitHeightStrategy,"I make sure that content element fits vertically within scalable element.

It makes sense to use me if scalable element has fixed or matching parent vertical size but fits content horizontally.",3,,I make sure that content element fits vertically within scalable element.,,,,,,,,,,,,,,,It makes sense to use me if scalable element has fixed or matching parent vertical size but fits content horizontally.,,,,,
E2,,E1 (disagree),BlGridLayoutUsageExamples,"I contain examples of a grid layout

I show how different resizing strategies work and how to build advanced layouts with the help of a grid",3,,"I contain examples of a grid layout

I show how different resizing strategies work and how to build advanced layouts with the help of a grid",,,,,,,,,,,,,,,,,,,,
E2,,E1 (disagree),GtConnectorButtonCreatedEvent,"Is sent by ButtonAttribute after button is created.

I allow Connector to be notified and attach its own additional handlers to newly created button",3,,"Is sent by ButtonAttribute after button is created.

I allow Connector to be notified and attach its own additional handlers to newly created button","Is sent by ButtonAttribute after button is created.

I allow Connector to be notified and attach its own additional handlers to newly created button",,,,,,,,,,,,,,,,Is sent by ButtonAttribute after button is created.,,,
E2,,E1 (agree),BlPerpendicularFractionAnchor,"I am a virtual anchor that lays on a perpendicular to a line between two reference anchors.

The curvature - distance from the line connecting reference anchors is defined as a fraction (curvatureFraction) of a length between anchors.",3,"I am a virtual anchor that lays on a perpendicular to a line between two reference anchors.
",I am a virtual anchor that lays on a perpendicular to a line between two reference anchors.,,,"
The curvature - distance from the line connecting reference anchors is defined as a fraction (curvatureFraction) of a length between anchors.",,,,,,,,,,,,,,,,,
E2,,E1 (agree),GtLibraryInstallerLogAnnouncement,"I am sent by installer when it tries to log some messages.

The UI may want to display them in a Transcript",3,,"I am sent by installer when it tries to log some messages.
","
The UI may want to display them in a Transcript",,,,,,,,,,,,,,,,,,,
E2,,E1 (agree),BrEditorTextFlowLine,"I represent a single line of a flow layout.

I store reference to the next line in order to avoid unnecessary array of lines creation for a very common case of just one line",3,I represent a single line of a flow layout.,"
I store reference to the next line in order to avoid unnecessary array of lines creation for a very common case of just one line",,,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BlSpartaMozSkiaCanvasBuilder,"I am a copy of class BlSpartaMozCanvasBuilder. This comment is copied from there, and might not be entirely accurate

I build sparta canvas using Moz2D backend",3,I am a copy of class BlSpartaMozCanvasBuilder.,I build sparta canvas using Moz2D backend,,,,,I am a copy of class BlSpartaMozCanvasBuilder.,,,,,,"This comment is copied from there, and might not be entirely accurate",,,,,,,,,
E2,,E3 (disagree),GtDiagrammerEditorList,"I display a list of editors of an object in a vertical list.

I fetch data from the diagrammer editor data source",3,,"I display a list of editors of an object in a vertical list.

I fetch data from the diagrammer editor data source","I display a list of editors of an object in a vertical list.

I fetch data from the diagrammer editor data source",,,,,,,,,,,,,,,,,,,
E2,,E3 (agree),BlMorphicHostSpace,"I am a host space created by BlMorphicHost.
I make it possible to embed Bloc space within arbitrary morphs.
For more information and example, please refer to BlMorphicHost.",3,"""I am a host space created by BlMorphicHost.",I make it possible to embed Bloc space within arbitrary morphs.,,,,,"
For more information and example, please refer to BlMorphicHost.""",,,,,,,,,,,,,,,
E2,,E3 (agree),BlScalableFitWidthStrategy,"I make sure that content element fits horizontally within scalable element.

It makes sense to use me if scalable element has fixed or matching parent horizontal size but fits content vertically.",3,,I make sure that content element fits horizontally within scalable element.,,,,,,,,,,,,,,,"
It makes sense to use me if scalable element has fixed or matching parent horizontal size but fits content vertically.",,,,,
E2,,E3 (agree),GtDiagrammerExamples,"!Diagrammer

[[[example=GtDiagrammerExamples>>#diagrammer|expanded=true|noCode=true|show=gtLiveIn:]]]",3,,,,,,,,,,"!Diagrammer

[[[example=GtDiagrammerExamples>>#diagrammer|expanded=true|noCode=true|show=gtLiveIn:]]]",,,,,,,,,,,,
E3,E2 (agree),,BlTime,"I encapsulate a concept of time and play a role of a time provider for Animations or other parts of the system that compute durations or how much time passed since some action.

Bloc components must not directly rely on system time or hardcode it in any place because it prevents us from simulating spaces. The use of me makes system exemplifiable",3,,I encapsulate a concept of time and play a role of a time provider for Animations or other parts of the system that compute durations or how much time passed since some action.,I encapsulate a concept of time and play a role of a time provider for Animations or other parts of the system that compute durations or how much time passed since some action.,,,,,,Animations,,,,Bloc components must not directly rely on system time or hardcode it in any place because it prevents us from simulating spaces. The use of me makes system exemplifiable,,,,,,,,,
E3,E2 (agree),,GtExampleDependenciesResolver,"I know how to extract the dependencies of a given example. The dependencies of a given example consists in message sends to other method constructing an example. 

To determine if a message send represents a dependency to a method containing an example, I use heuristic defined by subclasses of ==GtExampleDependencyResolver==. ",3,,I know how to extract the dependencies of a given example. The dependencies of a given example consists in message sends to other method constructing an example.,,,"To determine if a message send represents a dependency to a method containing an example, I use heuristic defined by subclasses of ==GtExampleDependencyResolver==.",,,, ==GtExampleDependencyResolver==,,,,,,,,,,,,,
E3,E2 (agree),,BlInfiniteDataSourceCommandType,"I am a type of data source update command.
I suppose to be stateless and therefore immutable.
For performance and memory reasons I provide a unique instance of me to be shared among my users",3,I am a type of data source update command.,,,,"I suppose to be stateless and therefore immutable.
For performance and memory reasons I provide a unique instance of me to be shared among my users",,,,,,,,,,,,,,,,,
E3,E2 (agree),,GtGraphTreemapSlice,"My subclasses implement treemap slice algorithms.
See my subclasses for more details and examples: ${class:GtGraphTreemapSlice|show=gtSubclassesFor:|expanded=true}$
",3,,,,,,,See my subclasses for more details and examples: ${class:GtGraphTreemapSlice|show=gtSubclassesFor:|expanded=true}$,"My subclasses implement treemap slice algorithms.
See my subclasses for more details and examples: ${class:GtGraphTreemapSlice|show=gtSubclassesFor:|expanded=true}$
",,,,,,,,,,,,,,
E3,E2 (disagree),,BlMouseMoveEvent,"The mouse move event is fired when a pointing device (usually a mouse) is moved while over an element.

https://developer.mozilla.org/en-US/docs/Web/Events/mousemove",3,,,The mouse move event is fired when a pointing device (usually a mouse) is moved while over an element.,,,,https://developer.mozilla.org/en-US/docs/Web/Events/mousemove,,,,,,,,https://developer.mozilla.org/en-US/docs/Web/Events/mousemove,,,,,,,
E3,,E1 (agree),GtPlotterScaleDomain,"In mathematics, and more specifically in naive set theory, the domain of definition (or simply the domain) of a function is the set of ""input"" or argument values for which the function is defined. That is, the function provides an ""output"" or value for each member of the domain.[1] Conversely, the set of values the function takes on as output is termed the image of the function, which is sometimes also referred to as the range of the function.

https://en.wikipedia.org/wiki/Domain_of_a_function",3,,,,,,,,,,,,,,,https://en.wikipedia.org/wiki/Domain_of_a_function,,,"In mathematics, and more specifically in naive set theory, the domain of definition (or simply the domain) of a function is the set of ""input"" or argument values for which the function is defined. That is, the function provides an ""output"" or value for each member of the domain.[1] Conversely, the set of values the function takes on as output is termed the image of the function, which is sometimes also referred to as the range of the function.",,,,
E3,,E1 (agree),BlSpaceFramePhase,"I represent a frame phase.

Each phase knows about its start time and send a corresponding event once the phase is completed.",3,I represent a frame phase.,Each phase knows about its start time and send a corresponding event once the phase is completed.,,,,,,,,,,,,,,,,,,,,
E3,,E1 (disagree),BlElementSelectionAcquiredEvent,"Is sent when element gets inside of mouse selection rectangle or when the overlapping rectangle formed by element's bounds and selection rectangle changes.

Text containing elements should react on this event and select a corresponding portion of text within selection rectangle",3,,,Is sent when element gets inside of mouse selection rectangle or when the overlapping rectangle formed by element's bounds and selection rectangle changes.,,,,,,,,,,Text containing elements should react on this event and select a corresponding portion of text within selection rectangle,,,,,,Is sent when element gets inside of mouse selection rectangle or when the overlapping rectangle formed by element's bounds and selection rectangle changes.,,,
E3,,E1 (disagree),BlElementPositionChangedEvent,"Is sent when element's position within its parent changes.

Note: position may change even if an element has no parent",3,,,Is sent when element's position within its parent changes.,,,,,,,,,,Note: position may change even if an element has no parent,,,,,,Is sent when element's position within its parent changes,,,
E3,,E1 (agree),GtPlotterAxisProjection,"I represent a projection value  of a domain object on the axis.

Given a Point (20@30) as a domain object and euclidian coordinate system.
Then projection of that point on continuous X-Axis would be 20 and projection on Y-axis would be 30.

A projection of a domain object on discrete axis is an index of that object in a data set",4-9,I represent a projection value of a domain object on the axis.,,,,A projection of a domain object on discrete axis is an index of that object in a data set,,,,,"Given a Point (20@30) as a domain object and euclidian coordinate system.
Then projection of that point on continuous X-Axis would be 20 and projection on Y-axis would be 30.",,,,,,,,,,,,
E1,E2 (agree),,BlDevScripterCheckFiredEventsStep,"I check whether particular ${class:BlEvent}$ events were fired on a ${class:BlElement}$ target.

!! Example

Here you can see how to configure a fire and check a click event on a child element:
${example:BlDevScripterExamples>>#clickCheck|previewExpanded=true|previewHeight=400}$",4-9,,I check whether particular ${class:BlEvent}$ events were fired on a ${class:BlElement}$ target.,,,,,,,,"!! Example

Here you can see how to configure a fire and check a click event on a child element:
${example:BlDevScripterExamples>>#clickCheck|previewExpanded=true|previewHeight=400}$
",,,,,,,,,,,,
E1,E2 (agree),,BlHostPulseLoop,"I am the Bloc main loop.
I indicate to the Universe that is time to synchronize the state of the elements. 

A pulse is fired every 16ms (if possible) to obtain 60 frames per second (fps) maximum.  This may be delayed if there are background processes wanting to run (to ensure that background calculation of UI elements can complete).  See ${method:name=BlPulseLoop>>#wait} for details of how the loop time is regulated.

The opened spaces listen the pulse to be synchronized and to update their state when it is needed.",4-9,I am the Bloc main loop.,I indicate to the Universe that is time to synchronize the state of the elements. ,,,A pulse is fired every 16ms (if possible) to obtain 60 frames per second (fps) maximum.  This may be delayed if there are background processes wanting to run (to ensure that background calculation of UI elements can complete). The opened spaces listen the pulse to be synchronized and to update their state when it is needed.,,See ${method:name=BlPulseLoop>>#wait} for details of how the loop time is regulated.,,,,,,,,,,,,,,,
E1,E2 (agree),,BlKeyCombination,"I represent an abstract key combination which is the most important part of ===BlShortcut===.
I define an event matching API that allows ===BlShortcutHandler=== to find the most appropriate shortcut for currently pressed keys.

I have support of Visitor pattern. See ===BlKeyCombinationVisitor===

See ===BlKeyCombinationExamples=== for related examples.",4-9,I represent an abstract key combination which is the most important part of ===BlShortcut===.,I define an event matching API that allows ===BlShortcutHandler=== to find the most appropriate shortcut for currently pressed keys.I have support of Visitor pattern,,,,,"See ===BlKeyCombinationVisitor===

See ===BlKeyCombinationExamples=== for related examples.",,"BlKeyCombinationVisitor
BlKeyCombinationExamples
BlShortcutHandler",,,,,,,,,,,,,
E1,E2 (agree),,BlClickEvent,"The click event is fired when a pointing device button (a mouse's primary button) is pressed and released on a single element.

The order of fired events:

 - Mouse Down
 - Mouse Up
 - Click",4-9,,The click event is fired when a pointing device button (a mouse's primary button) is pressed and released on a single element.,,,"The order of fired events:

 - Mouse Down
 - Mouse Up
 - Click",,,,,,,,,,,,,,,,,
E1,E2 (disagree),E3 (agree with E2),TSpTextRun,"I define an API of a Text run - an object that holds an array of glyphs that represent a piece of text.

Note that TextRun is optimised for the case of simple ASCII string (all chars are 8 bit), simple multilanguage string (all chars are 16 bit) and complex scripts (characters have various length of 8-32 bits).

Users should never instantiate TextRun directly, instead ask TextPainter to do the necessary job - it is needed to support backend specific text runs",4-9, an object that holds an array of glyphs that represent a piece of text.,I define an API of a Text run,,,"Note that TextRun is optimised for the case of simple ASCII string (all chars are 8 bit), simple multilanguage string (all chars are 16 bit) and complex scripts (characters have various length of 8-32 bits).",,,,,,,,"Note that TextRun is optimised for the case of simple ASCII string (all chars are 8 bit), simple multilanguage string (all chars are 16 bit) and complex scripts (characters have various length of 8-32 bits).

Users should never instantiate TextRun directly, instead ask TextPainter to do the necessary job - it is needed to support backend specific text runs",,,,,,,,,
E1,,E3 (agree),BlChildrenOrderedCollectionExamples,"I define examples for the class ${class:BlChildrenOrderedCollection}$.

Instances of ${class:BlChildrenOrderedCollection}$ are created by directly instatiating the class.
${example:BlChildrenOrderedCollectionExamples>>#emptyChildrenExplicitCreation}$

Bloc elements can then be added and removed from the collection.
${example:BlChildrenOrderedCollectionExamples>>#add}$

${example:BlChildrenOrderedCollectionExamples>>#remove}$",4-9,,I define examples for the class ${class:BlChildrenOrderedCollection}$.,,,,"Instances of ${class:BlChildrenOrderedCollection}$ are created by directly instatiating the class.
${example:BlChildrenOrderedCollectionExamples>>#emptyChildrenExplicitCreation}$",,,,"Bloc elements can then be added and removed from the collection
Bloc elements can then be added and removed from the collection.
${example:BlChildrenOrderedCollectionExamples>>#add}$

${example:BlChildrenOrderedCollectionExamples>>#remove}$",,,,,,,,,,,,
E1,,E3 (agree),BlFocusExamples,"How to:

        1) Inspect / run example
        2) Click one any cell to give it a focus (blue border should appear)
        3) Navigate with keyboard arrows (arrow up/down left/right)",4-9,,,,,,,,,,"How to:

        1) Inspect / run example
        2) Click one any cell to give it a focus (blue border should appear)
        3) Navigate with keyboard arrows (arrow up/down left/right)",,,,,,,,,,,,
E1,,E3 (agree),BlArrowheadTriangle,"I am a triangular arrow head.
My size depends on the width of a curve and hence can not be manually specified.

It is possible to have a border around triangle by specifying a border width of a triangle arrowhead.

I support background and border paints.
 - For hollow arrowhead let background be transparent.
 - For solid arrowhead make background paint be the same as border paint.
         (it is possible to specify different paints for border and background)",4-9,I am a triangular arrow head.,"My size depends on the width of a curve and hence can not be manually specified.
 I support background and border paints.
 - For hollow arrowhead let background be transparent.
 - For solid arrowhead make background paint be the same as border paint.
         (it is possible to specify different paints for border and background)",,,It is possible to have a border around triangle by specifying a border width of a triangle arrowhead.,,,,,,,,,,,,,,,,,
E1,,E3 (agree),BlMatrix2D,"I represent a matrix used for 2D affine transformations.
https://en.wikipedia.org/wiki/Matrix_(mathematics)

My components are named according to mathematical convention:

 |  a11  a12  |                 |   sx     shy  |
 |  a21  a22  |       =>     |  shx    sy    |
 |  a31  a32  |                 |    x        y     |",4-9,I represent a matrix used for 2D affine transformations.,,,,"My components are named according to mathematical convention:

 |  a11  a12  |                 |   sx     shy  |
 |  a21  a22  |       =>     |  shx    sy    |
 |  a31  a32  |                 |    x        y     |",,,,,,,,,,https://en.wikipedia.org/wiki/Matrix_(mathematics),,,,,,,
E1,,E3 (agree),BrTextEditor,"! The Moldable Editor

I edit text and provide high level abstractions of essential text editor functionality such as selection, cursor, text insertions and deletions.

I make use of ${class:BrTextAdornmentAttribute}$ to augment text with visual elements. 

I subclass infinite data source in order to be able to smoothly display practically infinite amounts of text.",4-9,! The Moldable Editor,"I edit text and provide high level abstractions of essential text editor functionality such as selection, cursor, text insertions and deletions.","
I make use of ${class:BrTextAdornmentAttribute}$ to augment text with visual elements. ",,,,,"
I subclass infinite data source in order to be able to smoothly display practically infinite amounts of text.",${class:BrTextAdornmentAttribute}$,,,,,,,,,,,,,
E2,,E1 (agree),BlPolygon,"Example:

BlPolygon vertices: { 
        10@50.
        50@20.
        150@40.
        180@150.
        80@140
}",4-9,,,,,,,,,,"Example:

BlPolygon vertices: { 
        10@50.
        50@20.
        150@40.
        180@150.
        80@140
}",,,,,,,,,,,,
E2,,E1 (agree),GtRlMajorVersionComputation,"I increment the major number of a semantic version. I reset both the patch and minor parts of the version number to zero.

${example:GtRlSemanticVersionComputationExamples>>#nextMajorVersionComputation}$

If the symbolic version number on which I am applied has a patch or a minor number I reset them to zero in the created version number.
${example:GtRlSemanticVersionComputationExamples>>#nextMajorVersionComputationResettingPatchAndMinorNumbers}$",4-9,,"I increment the major number of a semantic version. I reset both the patch and minor parts of the version number to zero.
",,,"

If the symbolic version number on which I am applied has a patch or a minor number I reset them to zero in the created version number.
",,,,,"
${example:GtRlSemanticVersionComputationExamples>>#nextMajorVersionComputationResettingPatchAndMinorNumbers}$ ${example:GtRlSemanticVersionComputationExamples>>#nextMajorVersionComputation}$",,,,,,,,,,,,
E2,,E1 (agree),BlArrowheadSimpleArrow,"I am a simple arrow-like arrowhead.
Both my size and arrow length depend on the curve width.

It is possible hovewer to customize a length fraction - how long should be the outer ""arrow"" compared to the length of the side of a nose triangle.

Users can also customise nose angle that tells how wide should the arrow lines be spread.
The with of the outer arrows can be specified by changing border width of a simple arrow arrowhead.

I support both background and border paint and can have hollow inner triangle.",4-9,"I am a simple arrow-like arrowhead.
Both my size and arrow length depend on the curve width.
","
I support both background and border paint and can have hollow inner triangle. 
The with of the outer arrows can be specified by changing border width of a simple arrow arrowhead.",,"
It is possible hovewer to customize a length fraction - how long should be the outer ""arrow"" compared to the length of the side of a nose triangle.
",,,,,,"
Users can also customise nose angle that tells how wide should the arrow lines be spread.",,,,,,,,,,,,
E2,,E1 (agree),GtGraphTreemapSquarifyLandscapeRectangle,"I represent a rectangle. My height is smaller than my width.
I layout ${class:GtGraphTreemapNode}$ along my shorter side (height).
I am used by ${class:GtGraphTreemapSquarifyStep}$.

!! Example

In the following example, I occupy top-right side of a total area with ${example:GtGraphTreemapLayoutExamples>>#squarifyWithFourNodesFirstArea|label=#nodesCount}$ nodes:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithFourNodesFirstArea|noCode}$",4-9,I represent a rectangle. My height is smaller than my width.,"
I layout ${class:GtGraphTreemapNode}$ along my shorter side (height).","I am used by ${class:GtGraphTreemapSquarifyStep}$.
",,,,,,,"
!! Example

In the following example, I occupy top-right side of a total area with ${example:GtGraphTreemapLayoutExamples>>#squarifyWithFourNodesFirstArea|label=#nodesCount}$ nodes:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithFourNodesFirstArea|noCode}$",,,,,,,,,,,,
E2,,E1 (disagree),BlExperimentalExamples,"I contain experimental examples that only work in manually prepared laboratory environments.

Trying to run these examples may result in undefined bahaviour such as: crash, infinite debugger windows spawning, unresponsive image, universe collapse or suddenly created black hole that will probably destroy our solar system.

Take care. Be conscious at all times.",4-9,,I contain experimental examples that only work in manually prepared laboratory environments.,,,,,,,,,,,"Trying to run these examples may result in undefined bahaviour such as: crash, infinite debugger windows spawning, unresponsive image, universe collapse or suddenly created black hole that will probably destroy our solar system.

Take care. Be conscious at all times.",,,,"
Trying to run these examples may result in undefined bahaviour such as: crash, infinite debugger windows spawning, unresponsive image, universe collapse or suddenly created black hole that will probably destroy our solar system. 
Take care. Be conscious at all times.",,I contain experimental examples that only work in manually prepared laboratory environments.,,,
E2,,E3 (agree),GtRlBaselineTagReleaseStrategy,"I am a release strategy that uses the current loaded tag for a repository as the version number.

I indicate a passive release as no actions need to be executed. The version number already exists in the repository.
I should only be used for repositories that have no child repositories or when all child repositories also use this strategy, as I hardcode an existing tag.
As I am passive I do not export any metadata. Even if the repository has child repositories there will be no metadata exported. Because of this I do not use metadata to check previous versions (it is not reliable).

I am a valid release strategy only when all Monticello baselines that load this project use the same tag to load it. 
See ${method:GtRlBaselineTagReleaseStrategy>>#assertCompatibleWithRepository:}$ for assertions that check when I can be used.",4-9,"""I am a release strategy that uses the current loaded tag for a repository as the version number.","""I am a release strategy that uses the current loaded tag for a repository as the version number.

I indicate a passive release as no actions need to be executed. The version number already exists in the repository.",,,As I am passive I do not export any metadata. Even if the repository has child repositories there will be no metadata exported. Because of this I do not use metadata to check previous versions (it is not reliable).,,,,,"


I am a valid release strategy only when all Monticello baselines that load this project use the same tag to load it. 
See ${method:GtRlBaselineTagReleaseStrategy>>#assertCompatibleWithRepository:}$ for assertio",,,,,,,"
I should only be used for repositories that have no child repositories or when all child repositories also use this strategy, as I hardcode an existing tag.",,,,,
E2,,E3 (agree),BlDecelerateInterpolator,"I am an interpolator where the rate of change starts out quickly and and then decelerates.

I am configurable using ""factor"" - a degree to which the animation should be eased. Setting factor to 1.0f produces an upside-down y=x^2 parabola. Increasing factor above 1.0f makes exaggerates the ease-out effect (i.e., it starts even faster and ends evens slower).

My formula is:
	f(x) = 1 - (1 - x)^n, where n = 2* factor

I meant to be immutable, therefore factor can be only set using factory method #factor: on my class side",4-9,"""I am an interpolator where the rate of change starts out quickly and and then decelerates.

I am configurable using """"factor"""" - a degree to which the animation should be eased. ","""I am an interpolator where the rate of change starts out quickly and and then decelerates.",,,"Setting factor to 1.0f produces an upside-down y=x^2 parabola. Increasing factor above 1.0f makes exaggerates the ease-out effect (i.e., it starts even faster and ends evens slower).

My formula is:
        f(x) = 1 - (1 - x)^n, where n = 2* factor

I meant to be immutable, therefore factor can be only set using factory method #factor: on my class side""",,,,,,,,,,,,,,,,,
E2,,E3 (disagree),BlTextUnderlineAttribute,"! Underline
I represent a text underline attribute.
I am used together with ${class:BlText}$ and ${class:TBlTextStyleable}$ to style text.

https://en.wikipedia.org/wiki/Underline

See ${class:BlTextUnderlineAttributeExamples}$ for examples",4-9,"
I represent a text underline attribute.
",I am used together with ${class:BlText}$ and ${class:TBlTextStyleable}$ to style text.,I am used together with ${class:BlText}$ and ${class:TBlTextStyleable}$ to style text.,,,,"
https://en.wikipedia.org/wiki/Underline

See ${class:BlTextUnderlineAttributeExamples}$ for examples",,,,,,,,https://en.wikipedia.org/wiki/Underline,,,,,,,
E2,,E3 (agree),BlElementDynamicTransformation,"I am dynamic element transformation in the sense that my transformation matrix may actually depend on some element properties such as #extent or #position.

It means that matrix computation is performed only when requested taking owner element into account.
This also means that the matrix dimension (2D or 3D) should be determined dynamically based on inner transformations",4-9,I am dynamic element transformation in the sense that my transformation matrix may actually depend on some element properties such as #extent or #position.,"I am dynamic element transformation in the sense that my transformation matrix may actually depend on some element properties such as #extent or #position.
",,,It means that matrix computation is performed only when requested taking owner element into account.,,,,,,,,,,,,This also means that the matrix dimension (2D or 3D) should be determined dynamically based on inner transformations,,,,,
E2,,E3 (disagree),GtRlCommitAndTagReleaseAction,"I execute a commit of the current changes staged for commit and push a tag corresponding to the version number of the repository release.

I only work with strategies of type ${class:GtRlSemanticTagReleaseStrategy}$. 
See ${method:GtRlSemanticTagReleaseStrategy>>#commitAndTagRelease} for more implementation details.",4-9,,I execute a commit of the current changes staged for commit and push a tag corresponding to the version number of the repository release.,"
I only work with strategies of type ${class:GtRlSemanticTagReleaseStrategy}$. ",,"
I only work with strategies of type ${class:GtRlSemanticTagReleaseStrategy}$. 
See ${method:GtRlSemanticTagReleaseStrategy>>#commitAndTagRelease} for more implementation details.",,"
See ${method:GtRlSemanticTagReleaseStrategy>>#commitAndTagRelease} for more implementation details.",,,,,,,,,,,,,,,
E3,E2 (agree),,BlMouseProcessor,"I am an event processor.
I convert basic events to more complex events.
For example, i generate events like click, dbl click, drag&drop, ... from mouse down, mouse up, and mouse move events.

Mouse actions are blocked during drag",4-9,I am an event processor.,I convert basic events to more complex events.,I convert basic events to more complex events.,,,,,,,"For example, i generate events like click, dbl click, drag&drop, ... from mouse down, mouse up, and mouse move events.",,,Mouse actions are blocked during drag,,,,,,,,,
E3,E2 (agree),,GtProtoTasker,"I am an abstract tasker defining mandatory methods for all taskers. 
Tasker is responsible for collectin ${class:GtTaskerTask}$ tasks and executing them when requested. 

Mandatory methods are: 
- ${method:GtProtoTasker>>#addTask:|expanded=true}$
- ${method:GtProtoTasker>>#flush|expanded=true}$

Interesting taskers to explore are ${class:GtTaskerOrderedNonRepetitive}$ and ${class:GtPostponingTasker}$.",4-9,I am an abstract tasker defining mandatory methods for all taskers. ,Tasker is responsible for collectin ${class:GtTaskerTask}$ tasks and executing them when requested.,,"Mandatory methods are: 
- ${method:GtProtoTasker>>#addTask:|expanded=true}$
- ${method:GtProtoTasker>>#flush|expanded=true}$",,,,Interesting taskers to explore are ${class:GtTaskerOrderedNonRepetitive}$ and ${class:GtPostponingTasker}$.," ${class:GtTaskerTask}$
 ${class:GtTaskerOrderedNonRepetitive}$
 ${class:GtPostponingTasker}$",,,,,,,,,,,,,
E3,E2 (agree),,GtGraphTreemapSliceHorizontalLayout,"I implement an horizontal slice algorithm.
I use ${class:GtGraphTreemapSliceHorizontal}$ to compute ${class:BlElement}$ children positions and extents.

!! Example 

${example:GtGraphTreemapLayoutExamples>>#numbersSliceHorizontal|codeExpanded=false|previewExpanded=true}$
",4-9,I implement an horizontal slice algorithm.,,I use ${class:GtGraphTreemapSliceHorizontal}$ to compute ${class:BlElement}$ children positions and extents.,,,,,," ${class:GtGraphTreemapSliceHorizontal}$
 ${class:BlElement}$","
!! Example 

${example:GtGraphTreemapLayoutExamples>>#numbersSliceHorizontal|codeExpanded=false|previewExpanded=true}$",,,,,,,,,,,,
E3,E2 (agree),,GtExampleProcessor,"I am an abstract class for manipulating examples.

My subclasses can add different semantics for different use cases. For example, evaluating an example is to be treated differently from a debugging scenario, or from a  scenario to recorver static dependencies.

I maintain a context that can be accessed from within the examples being processed during the execution of the processor.

#value - Execute the processor. Can return a value, depending on the processor.
#canProcess - Verifies if the processor can execute on the given example.",4-9,I am an abstract class for manipulating examples.,I maintain a context that can be accessed from within the examples being processed during the execution of the processor.,,"#value - Execute the processor. Can return a value, depending on the processor.
#canProcess - Verifies if the processor can execute on the given example.",,,,"My subclasses can add different semantics for different use cases. For example, evaluating an example is to be treated differently from a debugging scenario, or from a  scenario to recorver static dependencies.
",,"For example, evaluating an example is to be treated differently from a debugging scenario, or from a scenario to recorver static dependencies.",,,,,,,,,,,,
E3,E2 (agree),,BlElementEffect,"I am the abstract root class for effects.
I define the default drawing strategy (before & after).
My subclasses can be composed as a chain of effects.
I can influence the bounds of my owner (used to clip my owner).",4-9,I am the abstract root class for effects.,"I define the default drawing strategy (before & after).
I can influence the bounds of my owner (used to clip my owner).",,,,,,My subclasses can be composed as a chain of effects.,,,,,,,,,,,,,,
E3,,E1 (agree),BlDevScripterClickStep,"I fire a ${class:BlMouseDownEvent}$, ${class:BlMouseUpEvent}$, and ${class:BlClickEvent}$.

!! Example

Here you can see how to configure a fire and check a click event on a child element:
${example:BlDevScripterExamples>>#clickCheck|previewExpanded=true|previewHeight=400}$",4-9,,"I fire a ${class:BlMouseDownEvent}$, ${class:BlMouseUpEvent}$, and ${class:BlClickEvent}$.",,,,,,," ${class:BlMouseDownEvent}$
${class:BlMouseUpEvent}$
 ${class:BlClickEvent}$","!! Example

Here you can see how to configure a fire and check a click event on a child element:
${example:BlDevScripterExamples>>#clickCheck|previewExpanded=true|previewHeight=400}$",,,,,,,,,,,,
E3,,E1 (agree),BlChicken,"How to run:


==BlChicken open==",4-9,,,,,,,,,,"How to run:


==BlChicken open==",,,,,,,,,,,,
E3,E2 (agree with E1),E1 (disagree),GtExampleFactory,"I am a factory that can create ${class:GtExample}$ instances. 

Users should configure me with a #sourceClass:. This is the class used to look for methods defining examples. To create an example, a method defining an example is executed having a provider as a receiver. If the example method is defined on the class side, the provider is the class object. If the method is defined on the instance side, the provider consists in a new instance of that class. In the second case, a new instance is created for running each example method. Optionally users can configure the factory with an explicit provider. If this is done, this provider will be used for all examples created by the factory.

To initialize the subjects of an example I call #gtExampleSubjects on the provider object.
To initialize various properties of an example I detect all pragmas from the example method for which a method exists in class of the example (the method should have the same name as the pragma keyword). Then I execute those methods with the example as a receiver and the pragma arguments.",4-9,I am a factory that can create ${class:GtExample}$ instances.,,,Users should configure me with a #sourceClass:.,"Users should configure me with a #sourceClass:. This is the class used to look for methods defining examples. To create an example, a method defining an example is executed having a provider as a receiver. If the example method is defined on the class side, the provider is the class object. If the method is defined on the instance side, the provider consists in a new instance of that class. In the second case, a new instance is created for running each example method. Optionally users can configure the factory with an explicit provider. If this is done, this provider will be used for all examples created by the factory.

To initialize the subjects of an example I call #gtExampleSubjects on the provider object.
To initialize various properties of an example I detect all pragmas from the example method for which a method exists in class of the example (the method should have the same name as the pragma keyword). Then I execute those methods with the example as a receiver and the pragma arguments.",,,,${class:GtExample}$,"To initialize the subjects of an example I call #gtExampleSubjects on the provider object.
To initialize various properties of an example I detect all pragmas from the example method for which a method exists in class of the example (the method should have the same name as the pragma keyword). Then I execute those methods with the example as a receiver and the pragma arguments.",,,the method should have the same name as the pragma keyword,,,,Users should configure me with a #sourceClass:. the method should have the same name as the pragma keyword,,,,,
E3,,E1 (disagree),BrExamplesShowroom,"I am a collection of ""showroom"" examples.

! Buttons

In the example below we show all existing button styles
${example:BrExamplesShowroom class>>#allButtons|expanded|noCode}$

The following glamorous button reacts to various UI interaction events and changes its style according the state (pressed, hovered)
${example:BrExamplesShowroom>>#glamorousButton}$

Button can also be disabled to prevent click events
${example:BrExamplesShowroom>>#glamorousDisabledButton}$

! Toggles

Toggle buttons can have radically different look, while the behaviour of all of them is exactly the same.
${example:BrExamplesShowroom class>>#allToggles|noCode}$

!! Labelled toggle

To create a toggle button with a label user should the corresponding  ${class:BrMaterialToggleWithIconLook}$

${example:BrExamplesShowroom>>#materialLabelToggle}$

!! Iconified toggle

Similarly we can use the icon look to build an iconified toggle:
${example:BrExamplesShowroom>>#materialIconToggle}$

!! Iconified labelled toggle

We can compose label and icon looks to create a toggle button with both label and the icon. Note that the order of looks defines the visual order of the label and icon:

${example:BrExamplesShowroom>>#materialToggle}$

Thus being said by swapping the label and icon look we can move the icon to the right from the label:

${example:BrExamplesShowroom>>#materialReversedToggle}$

! Accordion

Accordion is the exandable and collapsable widget that consists of a header and a content. Any visual ${class:BlElement}$ can be a header of the accordion. The following example shows how a ${class:BrButton}$ can be used an accordion header:

${example:BrExamplesShowroom>>#accordion}$

! Tabs

The following example shows how to create a tab group widget with 3 tabs. The content of each tab is defined with the help of a stencil.

${example:BrExamplesShowroom>>#glamorousTabs}$

! Toolbar

The toolbar is a logical set of action buttons (either labelled or iconified).
${example:BrExamplesShowroom>>#glamorousToolbar}$
${example:BrExamplesShowroom>>#materialToolbar}$

! List

The example below describes how to instantiate a new instance of the simple list that only has one column:
${example:BrExamplesShowroom>>#simpleList|noCode}$

${example:BrExamplesShowroom>>#columnedList|noCode}$",10-113,"I am a collection of ""showroom"" examples.
",,,,,,,,,"
! Buttons

In the example below we show all existing button styles
${example:BrExamplesShowroom class>>#allButtons|expanded|noCode}$

The following glamorous button reacts to various UI interaction events and changes its style according the state (pressed, hovered)
${example:BrExamplesShowroom>>#glamorousButton}$

Button can also be disabled to prevent click events
${example:BrExamplesShowroom>>#glamorousDisabledButton}$

! Toggles

Toggle buttons can have radically different look, while the behaviour of all of them is exactly the same.
${example:BrExamplesShowroom class>>#allToggles|noCode}$

!! Labelled toggle

To create a toggle button with a label user should the corresponding  ${class:BrMaterialToggleWithIconLook}$

${example:BrExamplesShowroom>>#materialLabelToggle}$

!! Iconified toggle

Similarly we can use the icon look to build an iconified toggle:
${example:BrExamplesShowroom>>#materialIconToggle}$

!! Iconified labelled toggle

We can compose label and icon looks to create a toggle button with both label and the icon. Note that the order of looks defines the visual order of the label and icon:

${example:BrExamplesShowroom>>#materialToggle}$

Thus being said by swapping the label and icon look we can move the icon to the right from the label:

${example:BrExamplesShowroom>>#materialReversedToggle}$

! Accordion

Accordion is the exandable and collapsable widget that consists of a header and a content. Any visual ${class:BlElement}$ can be a header of the accordion. The following example shows how a ${class:BrButton}$ can be used an accordion header:

${example:BrExamplesShowroom>>#accordion}$

! Tabs

The following example shows how to create a tab group widget with 3 tabs. The content of each tab is defined with the help of a stencil.

${example:BrExamplesShowroom>>#glamorousTabs}$

! Toolbar

The toolbar is a logical set of action buttons (either labelled or iconified).
${example:BrExamplesShowroom>>#glamorousToolbar}$
${example:BrExamplesShowroom>>#materialToolbar}$

! List

The example below describes how to instantiate a new instance of the simple list that only has one column:
${example:BrExamplesShowroom>>#simpleList|noCode}$

${example:BrExamplesShowroom>>#columnedList|noCode}$",,,,,,,,,,,,
E3,,E1 (disagree),GtRlReleaseConfiguration,"I model options for configuring how releases are performed.

I am used by a ${class:GtRlReleaseBuilder}$ to create a new release. Users can configure default options that apply to all repositories from a release, or configure options for individual repositories.

My main API methods for setting other default options are:
- ${method:GtRlReleaseConfiguration>>#defaultReleaseBranchName:}$ The branch name on which to perform the release.
- ${method:GtRlReleaseConfiguration>>#defaultVersionComputation:}$ The strategy for computing the next version number in case a version already exists. These are subclasses of ${class:GtRlSemanticVersionComputation}$;
- ${method:GtRlReleaseConfiguration>>#defaultVersionNumber:}$ The version number to use in case there are no previous releases in a repository.
- ${method:GtRlReleaseConfiguration>>#forceNewRelease}$ Force a new release in a repository even if there no new changes in that repository and all dependencies did not change.

By default I use a release strategy of type ${class:GtRlDedicatedBranchReleaseStrategy}$. However, a custom release strategy can be configured for each indivual project using the method ${method:GtRlReleaseConfiguration>>#setReleaseStrategyOfType:forProjecs:}$.",10-113,,I model options for configuring how releases are performed.,"I am used by a ${class:GtRlReleaseBuilder}$ to create a new release. Users can configure default options that apply to all repositories from a release, or configure options for individual repositories.","
My main API methods for setting other default options are:
- ${method:GtRlReleaseConfiguration>>#defaultReleaseBranchName:}$ The branch name on which to perform the release.
- ${method:GtRlReleaseConfiguration>>#defaultVersionComputation:}$ The strategy for computing the next version number in case a version already exists. These are subclasses of ${class:GtRlSemanticVersionComputation}$;
- ${method:GtRlReleaseConfiguration>>#defaultVersionNumber:}$ The version number to use in case there are no previous releases in a repository.
- ${method:GtRlReleaseConfiguration>>#forceNewRelease}$ Force a new release in a repository even if there no new changes in that repository and all dependencies did not change.",,,,,,,,,"However, a custom release strategy can be configured for each indivual project using the method ${method:GtRlReleaseConfiguration>>#setReleaseStrategyOfType:forProjecs:}$.",,,"By default I use a release strategy of type ${class:GtRlDedicatedBranchReleaseStrategy}$. However, a custom release strategy can be configured for each indivual project using the method ${method:GtRlReleaseConfiguration>>#setReleaseStrategyOfType:forProjecs:}$.",,,,"However, a custom release strategy can be configured for each indivual project using the method ${method:GtRlReleaseConfiguration>>#setReleaseStrategyOfType:forProjecs:}$.",,
E1,E2 (agree),,BlTextBackgroundAttribute,"I represent a text background attribute.
I am used together with BrText and BrTextStyler to style text.

Public API and Key Messages

- paint: set background paint

Example:

        BrTextBackgroundAttribute paint: Color yellow
 
Internal Representation and Key Implementation Points.

    Instance Variables
        paint:                <Object> can be a Color, Pattern, Gradient. Basically anything that is knows how to convert itself to canvas specific paint",10-113,I represent a text background attribute.,I am used together with BrText and BrTextStyler to style text.,I am used together with BrText and BrTextStyler to style text.,"
Public API and Key Messages

- paint: set background paint",,"   Instance Variables
        paint:                <Object> can be a Color, Pattern, Gradient. Basically anything that is knows how to convert itself to canvas specific paint",,,,"
Example:

        BrTextBackgroundAttribute paint: Color yellow",,,,,,,,,,,,
E1,E2 (agree),,BrTextEditorExamples,"! Today we will learn how to compose an editor 🙊

==It is as simple as computing a factorial, a piece of cake! == 🍰

[[[show=gtPrintIn:
        10 factorial
]]]

!!! 🔹 First create the text 💁

[[[example=BrTextEditorExamples>>#newText]]]

!!! 🔸 Next, we build the editor 👷

[[[example=BrTextEditorExamples>>#newEditor]]]

!!! 🔹 Then, we attach text to the enditor. 💡

[[[example=BrTextEditorExamples>>#editor:text:]]]

!!! 🔸 Next, we create an editor element. 🤘

[[[example=BrTextEditorExamples>>#newElement|show=gtLiveIn:]]]

!!! 🔹 And finally, build everything together 💪

[[[example=BrTextEditorExamples>>#element:editorText:|show=gtLiveIn:]]]

! Done 😎",10-113,,! Today we will learn how to compose an editor 🙊,,,,,,,,"[[show=gtPrintIn:
        10 factorial
]]]

!!! 🔹 First create the text 💁

[[[example=BrTextEditorExamples>>#newText]]]

!!! 🔸 Next, we build the editor 👷

[[[example=BrTextEditorExamples>>#newEditor]]]

!!! 🔹 Then, we attach text to the enditor. 💡

[[[example=BrTextEditorExamples>>#editor:text:]]]

!!! 🔸 Next, we create an editor element. 🤘

[[[example=BrTextEditorExamples>>#newElement|show=gtLiveIn:]]]

!!! 🔹 And finally, build everything together 💪

[[[example=BrTextEditorExamples>>#element:editorText:|show=gtLiveIn:]]]

! Done 😎",,,,,,,,,,,,
E1,E2 (agree),,SpartaCairoTextMetrics,"I store the extents of a single glyph or a string of glyphs in user-space coordinates. Because text extents are in user-space coordinates, they are mostly, but not entirely, independent of the current transformation matrix. If you call cairo_scale(cr, 2.0, 2.0), text will be drawn twice as big, but the reported text extents will not be doubled. They will change slightly due to hinting (so you can't assume that metrics are independent of the transformation matrix), but otherwise will remain unchanged.

bearingX - the horizontal distance from the origin to the leftmost part of the glyphs as drawn. Positive if the glyphs lie entirely to the right of the origin.

bearingY - the vertical distance from the origin to the topmost part of the glyphs as drawn. Positive only if the glyphs lie completely below the origin; will usually be negative.

width - width of the glyphs as drawn

height - height of the glyphs as drawn

advanceX - distance to advance in the X direction after drawing these glyphs

advanceY - distance to advance in the Y direction after drawing these glyphs. Will typically be zero except for vertical text layout as found in East-Asian languages.",10-113,,I store the extents of a single glyph or a string of glyphs in user-space coordinates.,,,"Because text extents are in user-space coordinates, they are mostly, but not entirely, independent of the current transformation matrix. If you call cairo_scale(cr, 2.0, 2.0), text will be drawn twice as big, but the reported text extents will not be doubled. They will change slightly due to hinting (so you can't assume that metrics are independent of the transformation matrix), but otherwise will remain unchanged.","
bearingX - the horizontal distance from the origin to the leftmost part of the glyphs as drawn. Positive if the glyphs lie entirely to the right of the origin.

bearingY - the vertical distance from the origin to the topmost part of the glyphs as drawn. Positive only if the glyphs lie completely below the origin; will usually be negative.

width - width of the glyphs as drawn

height - height of the glyphs as drawn

advanceX - distance to advance in the X direction after drawing these glyphs

advanceY - distance to advance in the Y direction after drawing these glyphs. Will typically be zero except for vertical text layout as found in East-Asian languages.",,,,,,,"They will change slightly due to hinting (so you can't assume that metrics are independent of the transformation matrix), but otherwise will remain unchanged.",,,,,,,,,
E1,E2 (agree),,SpartaLine,"I represent a line.

I am meant to be polymorphic with Rectangle and Path and can be used as path in various operations, except clipping.

Public API and Key Messages

- from get my start point
- to get my end point

  SpartaLine from: 10@10 to: 20@20
 
Internal Representation and Key Implementation Points.

    Instance Variables
        from:                <Point>
        to:                <Point>


    Implementation Points",10-113,I represent a line.,"I am meant to be polymorphic with Rectangle and Path and can be used as path in various operations, except clipping.",,"Public API and Key Messages

- from get my start point
- to get my end point

  SpartaLine from: 10@10 to: 20@20
 ",,"    Instance Variables
        from:                <Point>
        to:                <Point>",,,,,,,,,,,,,,,,
E1,E2 (agree),,GtPhlowForwarderView,"I forward a view definition to another object.
I am useful in situations when the object that has the view definition is expensive to create.
I am also useful in situtions, when the object is created only for the purpose of the view.

I create the object only if someone clicks on my tab (view).

!! Important

${method:GtPhlowView>>#title}$ and ${method:GtPhlowView>>#priority}$ are not taken from the original view. If that were the case, the advantage of the solution would be lost since the title and priority are necessary to build the view tab using the title and priority.

!! Example

You can define me as follow: ${method:GtPhlowViewExamples>>#gtForwardedViewFor:|expanded=true}$",10-113,,"I forward a view definition to another object.
I am useful in situations when the object that has the view definition is expensive to create.
I am also useful in situtions, when the object is created only for the purpose of the view.

I create the object only if someone clicks on my tab (view).",,,,,,,,"
!! Example

You can define me as follow: ${method:GtPhlowViewExamples>>#gtForwardedViewFor:|expanded=true}$",,,"!! Important

${method:GtPhlowView>>#title}$ and ${method:GtPhlowView>>#priority}$ are not taken from the original view. If that were the case, the advantage of the solution would be lost since the title and priority are necessary to build the view tab using the title and priority.",,,,,,,,,
E1,,E3 (agree),BlInfiniteDataSourceItemRangeMoved,"Sent when an item reflected at ===from=== position has been moved to ===to=== position.
This is a structural change event. Representations of other existing items in the data set are still considered up to date and will not be rebound, though their positions may be altered.

Sent by:
        - BlInfiniteDataSource
        
Example:

infiniteElement dataSource
        addEventHandlerOn: BlInfiniteDataSourceItemRangeMoved
        do: [ :event | self inform: 'Item was moved from: ', event from asString, ' to: ', event to asString ]",10-113,,"This is a structural change event. Representations of other existing items in the data set are still considered up to date and will not be rebound, though their positions may be altered.
","
Sent by:
        - BlInfiniteDataSource",,,,,,BlInfiniteDataSource,"        
Example:

infiniteElement dataSource
        addEventHandlerOn: BlInfiniteDataSourceItemRangeMoved
        do: [ :event | self inform: 'Item was moved from: ', event from asString, ' to: ', event to asString ]",,,,,,,,,Sent when an item reflected at ===from=== position has been moved to ===to=== position.,,,
E1,,E3 (agree),GtGradAbstractTreeLayout,"This an implementation of a Moen's tree layout algorithm.
Moen's algorithm attempts to create a tree with a triangular shape and place nodes somewhat simetrically. It is an extension of the well-known Reingold-Tilfold algorithm. It improved the older algorithm's ability to handle non-uniform sized nodes. Moen's trees are oriented horizontally. However, this implementation offers the posibility of choosing the orientation - vertical or horizontal. 

The Reingold-Tilfold  algorithm, and thus Moen's also,  starts with a bottom-up traversal of the tree. It calculates left and right subtrees of a tree and merges them. When doing that, it makes sure that the parents are centered above their children. Reignold-Tilfold's algorithm  was originally designed only for binary trees, but later extended to work for non-binary ones as well.  While Reignold-Tilfold's algorithm produces a compact tree layout, Moen's strives to make a tighter one. To accomplish that, it uses shapes represented by polyline structures. These shapes are initially formed for each leaf, so that the polyline goes around the node, but leaves the left side open. During the first phase of the algorithm's execution (bottom-up traversal), these shapes  are merged - shapes of parents are merged with shapes of children. In this implementation, we call the polylines contours. When merging contours, minimum horizontal/vertical offsets at which siblings can be placed with resepct to  their upper (left) sibling (depending of the layout's orientation) are calculated

Once the bottom-up traversal is finished,  calculation of offsets is finished as well. At that point, the tree is traversed again, but this time from top (root) to the bottom. During this second traversal, positions of the tree's nodes are set. Calculation of positions factors in the mentioned offsets, as well as the positions of the node's parent and the layout's  node and level distance properties.

Additionally, this implementation supports alignment of  nodes (top, center, bottom in case of the vertical layout and left, center, right in case of the horizontal layout). This is done through calculation of differences in sizes of nodes compared to the largest nodes on the same level, as well as the differences in sizes of their parents compared to the largest nodes on the parent level.

GtGradTreeLayout is  a superclass of GtGradHorizontalTreeLayout and GtGradVerticalTreeLayout classes and  contains generic tree layout methods and definitions of methods the two subclasses need to redefine.  Generally, the differences between the implementations of  the hozitonal and vertical variants  are really small, revolving around one using  or setting the x and the other y coordinates.

The tree algorithms can be  used to lay out inner elements of a Bloc element or a Mondrian view.",10-113,This an implementation of a Moen's tree layout algorithm.,"However, this implementation offers the posibility of choosing the orientation - vertical or horizontal. 
 In this implementation, we call the polylines contours. When merging contours, minimum horizontal/vertical offsets at which siblings can be placed with resepct to  their upper (left) sibling (depending of the layout's orientation) are calculated

Once the bottom-up traversal is finished,  calculation of offsets is finished as well. At that point, the tree is traversed again, but this time from top (root) to the bottom. During this second traversal, positions of the tree's nodes are set. Calculation of positions factors in the mentioned offsets, as well as the positions of the node's parent and the layout's  node and level distance properties.

Additionally, this implementation supports alignment of  nodes (top, center, bottom in case of the vertical layout and left, center, right in case of the horizontal layout). This is done through calculation of differences in sizes of nodes compared to the largest nodes on the same level, as well as the differences in sizes of their parents compared to the largest nodes on the parent level.","GtGradTreeLayout is  a superclass of GtGradHorizontalTreeLayout and GtGradVerticalTreeLayout classes and  contains generic tree layout methods and definitions of methods the two subclasses need to redefine.  Generally, the differences between the implementations of  the hozitonal and vertical variants  are really small, revolving around one using  or setting the x and the other y coordinates.",,"Moen's algorithm attempts to create a tree with a triangular shape and place nodes somewhat simetrically. It is an extension of the well-known Reingold-Tilfold algorithm. It improved the older algorithm's ability to handle non-uniform sized nodes. Moen's trees are oriented horizontally.

The Reingold-Tilfold  algorithm, and thus Moen's also,  starts with a bottom-up traversal of the tree. It calculates left and right subtrees of a tree and merges them. When doing that, it makes sure that the parents are centered above their children. Reignold-Tilfold's algorithm  was originally designed only for binary trees, but later extended to work for non-binary ones as well.  While Reignold-Tilfold's algorithm produces a compact tree layout, Moen's strives to make a tighter one. To accomplish that, it uses shapes represented by polyline structures. These shapes are initially formed for each leaf, so that the polyline goes around the node, but leaves the left side open. During the first phase of the algorithm's execution (bottom-up traversal), these shapes  are merged - shapes of parents are merged with shapes of children.",,,"GtGradTreeLayout is  a superclass of GtGradTreeLayout and GtGradVerticalTreeLayout classes and  contains generic tree layout methods and definitions of methods the two subclasses need to redefine.  Generally, the differences between the implementations of  the hozitonal and vertical variants  are really small, revolving around one using  or setting the x and the other y coordinates.","GtGradTreeLayout
GtGradTreeLayout
GtGradVerticalTreeLayout",,,,,,,The tree algorithms can be  used to lay out inner elements of a Bloc element or a Mondrian view.,,,,,,
E1,,E3 (agree),BlTextElementMeasurementStrategyExamples,"! Text measurement strategies

${class:BlTextElement}$ provides different text measurement strategies, each suitable for a specific use case. There is no perfect strategy, therefore understanding the differences between them is an important step in learning how to work with Text in Bloc.

!! Label measurement

The default text measurement strategy is so called ==Label measurement==, ${method:BlTextElement>>#labelMeasurement}$. The height of the text element in this case is a sum of ascent and descent which is given by the font. It means that the height of the text is independent from the content. The width is given by the exact bounds of the element's text. ==Label measurement== is useful for displaying labels and short pieces of text. Please note, that since the width is precise and depends on the content, whitespace is not taken into account when computing the width of the text element.
${example:BlTextElementMeasurementStrategyExamples>>#textElementWithLabelMeasurement|noCode|previewShow=#gtLiveFor:|previewHeight=100}$

!! Editor measurement

A similar measurement strategy which is designed to be used in a text editor computes the width of the element using the ==#advance== property of a text paragraph. The height is computed as a sum of ascent and descent. ${method:BlTextElement>>#editorMeasurement}$
${example:BlTextElementMeasurementStrategyExamples>>#textElementWithEditorMeasurement|noCode|previewShow=#gtLiveFor:|previewHeight=100}$

!! Precise measurement

However, sometimes we want to know the exact and precise text bounds. ${method:BlTextElement>>#tightMeasurement}$ does exactly that and clips off any white space surrounding the text. It may be useful for displaying a short piece of a text, usually a word centered within a larger element.
${example:BlTextElementMeasurementStrategyExamples>>#textElementWithTightMeasurement|noCode|previewShow=#gtLiveFor:|previewHeight=75}$

!! Conslusion

Now let's compare all text measurement strategies:
${example:BlTextElementMeasurementStrategyExamples>>#measurementDifference|noCode|previewShow=#gtLiveFor:|previewHeight=220}$",10-113,,,"
${class:BlTextElement}$ provides different text measurement strategies, each suitable for a specific use case. There is no perfect strategy, therefore understanding the differences between them is an important step in learning how to work with Text in Bloc.",,,,,,,"Now let's compare all text measurement strategies:
""! Text measurement strategies

${class:BlTextElement}$ provides different text measurement strategies, each suitable for a specific use case. There is no perfect strategy, therefore understanding the differences between them is an important step in learning how to work with Text in Bloc.

!! Label measurement

The default text measurement strategy is so called ==Label measurement==, ${method:BlTextElement>>#labelMeasurement}$. The height of the text element in this case is a sum of ascent and descent which is given by the font. It means that the height of the text is independent from the content. The width is given by the exact bounds of the element's text. ==Label measurement== is useful for displaying labels and short pieces of text. Please note, that since the width is precise and depends on the content, whitespace is not taken into account when computing the width of the text element.
${example:BlTextElementMeasurementStrategyExamples>>#textElementWithLabelMeasurement|noCode|previewShow=#gtLiveFor:|previewHeight=100}$

!! Editor measurement

A similar measurement strategy which is designed to be used in a text editor computes the width of the element using the ==#advance== property of a text paragraph. The height is computed as a sum of ascent and descent. ${method:BlTextElement>>#editorMeasurement}$
${example:BlTextElementMeasurementStrategyExamples>>#textElementWithEditorMeasurement|noCode|previewShow=#gtLiveFor:|previewHeight=100}$

!! Precise measurement

However, sometimes we want to know the exact and precise text bounds. ${method:BlTextElement>>#tightMeasurement}$ does exactly that and clips off any white space surrounding the text. It may be useful for displaying a short piece of a text, usually a word centered within a larger element.
${example:BlTextElementMeasurementStrategyExamples>>#textElementWithTightMeasurement|noCode|previewShow=#gtLiveFor:|previewHeight=75}$

!! Conslusion

Now let's compare all text measurement strategies:
${example:BlTextElementMeasurementStrategyExamples>>#measurementDifference|noCode|previewShow=#gtLiveFor:|previewHeight=220}$""",,,,,,,,,,,,
E1,E2 (agree with E3),E3 (disagree),GtGraphCircleEnclosure,"! Smallest enclosing circle of circles

I compute the smallest circle that encloses the specified array of circles. The enclosing circle is computed using the *Matoušek-Sharir-Welzl>http://www.inf.ethz.ch/personal/emo/PublFiles/SubexLinProg_ALG16_96.pdf* algorithm.

The implementation is based on *d3.packEnclose(circles)>https://github.com/d3/d3-hierarchy/blob/master/src/pack/enclose.js*

Let's start with an empty enclosure:
${example:GtGraphCircleEnclosureExamples>>#emptyEnclosure|previewShow=#gtPreviewFor:|previewHeight=300}$

and add circles one by one, starting with a larger one. A circle enclosure is represented by a cyan circle. An enclosure of a single circle is a special case and can be computed directly by ${method:GtGraphCircleEnclosure class>>#enclosure:}$. Note, that the added circle has a margin set which is taken into account by enclosure:
${example:GtGraphCircleEnclosureExamples>>#enclosureWithOneCircle|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$

adding a second circle expands the enclosure circle to fit both circles ==C1== and ==C2==. Two circle enclosure is also a special case and can be derived directly by ${method:GtGraphCircleEnclosure class>>#enclosure:and:}$
${example:GtGraphCircleEnclosureExamples>>#enclosureWithTwoCircles|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$

Three circle enclosure is a special case too. ${method:GtGraphCircleEnclosure class>>#enclosure:and:and:}$ is responsible for the computation. Let's add the third circle to our enclosure to see the result: 
${example:GtGraphCircleEnclosureExamples>>#enclosureWithThreeCircles|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$

Starting with four circles, an enclosure should be computed recursively by building and updating a basis enclosure consisting of one to three circles: ${method:GtGraphCircleEnclosure class>>#enclosureAll:}$. 

${example:GtGraphCircleEnclosureExamples>>#enclosureWithFourCircles|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$",10-113,! Smallest enclosing circle of circles,I compute the smallest circle that encloses the specified array of circles. The enclosing circle is computed using the,,,,,"The enclosing circle is computed using the *Matoušek-Sharir-Welzl>http://www.inf.ethz.ch/personal/emo/PublFiles/SubexLinProg_ALG16_96.pdf* algorithm.
The implementation is based on *d3.packEnclose(circles)>https://github.com/d3/d3-hierarchy/blob/master/src/pack/enclose.js",,,"${example:GtGraphCircleEnclosureExamples>>#emptyEnclosure|previewShow=#gtPreviewFor:|previewHeight=300}$

and add circles one by one, starting with a larger one. A circle enclosure is represented by a cyan circle. An enclosure of a single circle is a special case and can be computed directly by ${method:GtGraphCircleEnclosure class>>#enclosure:}$. Note, that the added circle has a margin set which is taken into account by enclosure:
${example:GtGraphCircleEnclosureExamples>>#enclosureWithOneCircle|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$

adding a second circle expands the enclosure circle to fit both circles ==C1== and ==C2==. Two circle enclosure is also a special case and can be derived directly by ${method:GtGraphCircleEnclosure class>>#enclosure:and:}$
${example:GtGraphCircleEnclosureExamples>>#enclosureWithTwoCircles|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$

Three circle enclosure is a special case too. ${method:GtGraphCircleEnclosure class>>#enclosure:and:and:}$ is responsible for the computation. Let's add the third circle to our enclosure to see the result: 
${example:GtGraphCircleEnclosureExamples>>#enclosureWithThreeCircles|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$

Starting with four circles, an enclosure should be computed recursively by building and updating a basis enclosure consisting of one to three circles: ${method:GtGraphCircleEnclosure class>>#enclosureAll:}$. 

${example:GtGraphCircleEnclosureExamples>>#enclosureWithFourCircles|previewShow=#gtPreviewFor:|previewExpanded|previewHeight=300}$",,,,,"http://www.inf.ethz.ch/personal/emo/PublFiles/SubexLinProg_ALG16_96.pdf
https://github.com/d3/d3-hierarchy/blob/master/src/pack/enclose.js",,,,,,,
E1,E2 (agree with E3),E3 (disagree),GtGraphTreemapSquarify,"I split an area into rectangles that are close to squares (aspect ratio 1) as much as possible.
I use ${method:GtGraphTreemapNode>>#weight}$ node values to split an area into.
I use ${class:GtGraphTreemapSquarifyStep}$ to split area into sub-areas and measure ${class:GtGraphTreemapNode}$ positions and extends.

The algorithm is implemented as described in the paper by Mark Bruls, Kees Huizing, and Jarke J. van Wij, ""Squarified Treemaps"" [*PDF>https://www.win.tue.nl/~vanwijk/stm.pdf*].

!! Algorithm Explanation

This is an adapted extract from the paper Squarified Treemaps mentioned above. Suppose we have a rectangle with width ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|label=#width}$ and height ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|label=#height}$, and furthermore suppose that this rectangle must be subdivided in seven rectangles with areas ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|label=#nodeValues}$. The area will be subdivided as follows:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|noCode|codeExpanded=false|previewExpanded=true|previewShow=#gtPreviewFor:}$

The *first step* of our algorithm is to split the initial rectangle. We choose for a horizontal subdivision, because the original rectangle is wider than high. We next fill the left half. First we add a single rectangle. The aspect ratio of this first rectangle is ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFirstStep|label=#worstValueRounded}$.

${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFirstStep|previewExpanded=true|noCode}$

Next we add a second rectangle, above the first. The worst aspect ratio improves to ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSecondStep|label=#worstValueRounded}$.
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSecondStep|previewExpanded=true|noCode}$

However, if we add the next (area 4) above these original rectangles, the aspect ratio of this rectangle is ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesThirdStep|label=#worstValueRounded}$.
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesThirdStep|previewExpanded=true|noCode}$

Therefore, we decide that we have reached an optimum for the left half in step two, and start processing the right half. The initial subdivision we choose here is vertical, because the rectangle is higher than wider. In step 4 we add the rectangle with area 4:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFourthStep|previewExpanded=true|noCode}$

In the next step, we add area 3. The worst aspect ratio decreases from ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFourthStep|label=#worstValueRounded}$ to ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFifthStep|label=#worstValueRounded}$: 
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFifthStep|previewExpanded=true|noCode}$

Addition of the next (area 2) however does not improve the result as the worst aspect ratio increases from ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFifthStep|label=#worstValueRounded}$ to ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSixthStep|label=#worstValueRounded}$:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSixthStep|previewExpanded=true|noCode}$

So we reject the previous step and start to fill the right top partition:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSeventhStep|previewExpanded=true|noCode}$
 
These steps are repeated until all rectangles have been processed. The final result is the following:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|noCode|codeExpanded=false|previewExpanded=true}$.

An optimal result can not be guaranteed, and counterexamples can be set up. The order in which the rectangles are processed is important. We found that a decreasing order usually gives the best results. The initially large rectangle is then filled in first with the larger subrectangles.",10-113,,"I split an area into rectangles that are close to squares (aspect ratio 1) as much as possible.
I use ${method:GtGraphTreemapNode>>#weight}$ node values to split an area into.
I use ${class:GtGraphTreemapSquarifyStep}$ to split area into sub-areas and measure ${class:GtGraphTreemapNode}$ positions and extends.","I use ${method:GtGraphTreemapNode>>#weight}$ node values to split an area into.
I use ${class:GtGraphTreemapSquarifyStep}$ to split area into sub-areas and measure ${class:GtGraphTreemapNode}$ positions and extends.",,,,"The algorithm is implemented as described in the paper by Mark Bruls, Kees Huizing, and Jarke J. van Wij, ""Squarified Treemaps"" [*PDF>https://www.win.tue.nl/~vanwijk/stm.pdf*].",,,"! Algorithm Explanation

This is an adapted extract from the paper Squarified Treemaps mentioned above. Suppose we have a rectangle with width ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|label=#width}$ and height ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|label=#height}$, and furthermore suppose that this rectangle must be subdivided in seven rectangles with areas ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|label=#nodeValues}$. The area will be subdivided as follows:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|noCode|codeExpanded=false|previewExpanded=true|previewShow=#gtPreviewFor:}$

The *first step* of our algorithm is to split the initial rectangle. We choose for a horizontal subdivision, because the original rectangle is wider than high. We next fill the left half. First we add a single rectangle. The aspect ratio of this first rectangle is ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFirstStep|label=#worstValueRounded}$.

${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFirstStep|previewExpanded=true|noCode}$

Next we add a second rectangle, above the first. The worst aspect ratio improves to ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSecondStep|label=#worstValueRounded}$.
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSecondStep|previewExpanded=true|noCode}$

However, if we add the next (area 4) above these original rectangles, the aspect ratio of this rectangle is ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesThirdStep|label=#worstValueRounded}$.
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesThirdStep|previewExpanded=true|noCode}$

Therefore, we decide that we have reached an optimum for the left half in step two, and start processing the right half. The initial subdivision we choose here is vertical, because the rectangle is higher than wider. In step 4 we add the rectangle with area 4:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFourthStep|previewExpanded=true|noCode}$

In the next step, we add area 3. The worst aspect ratio decreases from ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFourthStep|label=#worstValueRounded}$ to ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFifthStep|label=#worstValueRounded}$: 
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFifthStep|previewExpanded=true|noCode}$

Addition of the next (area 2) however does not improve the result as the worst aspect ratio increases from ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesFifthStep|label=#worstValueRounded}$ to ${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSixthStep|label=#worstValueRounded}$:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSixthStep|previewExpanded=true|noCode}$

So we reject the previous step and start to fill the right top partition:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodesSeventhStep|previewExpanded=true|noCode}$
 
These steps are repeated until all rectangles have been processed. The final result is the following:
${example:GtGraphTreemapLayoutExamples>>#squarifyWithSevenNodes|noCode|codeExpanded=false|previewExpanded=true}$.",,"The algorithm is implemented as described in the paper by Mark Bruls, Kees Huizing, and Jarke J. van Wij, ""Squarified Treemaps"" [*PDF>https://www.win.tue.nl/~vanwijk/stm.pdf*].","An optimal result can not be guaranteed, and counterexamples can be set up. The order in which the rectangles are processed is important.",,https://www.win.tue.nl/~vanwijk/stm.pdf,,,We found that a decreasing order usually gives the best results. The initially large rectangle is then filled in first with the larger subrectangles.,, The order in which the rectangles are processed is important.,,
E2,,E1 (disagree),GtGraphForceBasedLayout,"A ROForceBasedLayout is inspired from the Code of D3. The original d3 version may be found on: http://bl.ocks.org/mbostock/4062045

Layout algorithm inspired by Tim Dwyer and Thomas Jakobsen.

Instance Variables
        alpha:                <Object>
        center:                <Object>
        charge:                <Object>
        charges:                <Object>
        fixedNodes:                <Object>
        friction:                <Object>
        gravity:                <Object>
        layoutInitial:                <Object>
        length:                <Object>
        lengths:                <Object>
        nodes:                <Object>
        oldPositions:                <Object>
        strength:                <Object>
        strengths:                <Object>
        theta:                <Object>
        weights:                <Object>

alpha
        - xxxxx

center
        - xxxxx

charge
        - xxxxx

charges
        - xxxxx

fixedNodes
        - xxxxx

friction
        - xxxxx

gravity
        - xxxxx

layoutInitial
        - xxxxx

length
        - xxxxx

lengths
        - xxxxx

nodes
        - xxxxx

oldPositions
        - xxxxx

strength
        - xxxxx

strengths
        - xxxxx

theta
        - xxxxx

weights
        - xxxxx",10-113,A ROForceBasedLayout is inspired from the Code of D3. ,,,,,"Instance Variables
        alpha:                <Object>
        center:                <Object>
        charge:                <Object>
        charges:                <Object>
        fixedNodes:                <Object>
        friction:                <Object>
        gravity:                <Object>
        layoutInitial:                <Object>
        length:                <Object>
        lengths:                <Object>
        nodes:                <Object>
        oldPositions:                <Object>
        strength:                <Object>
        strengths:                <Object>
        theta:                <Object>
        weights:                <Object>

alpha
        - xxxxx

center
        - xxxxx

charge
        - xxxxx

charges
        - xxxxx

fixedNodes
        - xxxxx

friction
        - xxxxx

gravity
        - xxxxx

layoutInitial
        - xxxxx

length
        - xxxxx

lengths
        - xxxxx

nodes
        - xxxxx

oldPositions
        - xxxxx

strength
        - xxxxx

strengths
        - xxxxx

theta
        - xxxxx

weights
        - xxxxx","The original d3 version may be found on: http://bl.ocks.org/mbostock/4062045

Layout algorithm inspired by Tim Dwyer and Thomas Jakobsen.
",,,,,,,, The original d3 version may be found on: http://bl.ocks.org/mbostock/4062045,,,,,,Layout algorithm inspired by Tim Dwyer and Thomas Jakobsen.,
E2,,E1 (agree),XdDocumentsExamples,"!! How-To Create Base64 String

[[[
| aDocument anXdFile |
aDocument := Gt2DocumentExamples new documentWithExistingClass.
anXdFile := aDocument saveToXDoc.
ZnBase64Encoder new 
        breakLines;
        encode: anXdFile streamingStrategy bytes 
]]]",10-113,,,,,,,,,,"!! How-To Create Base64 String

[[[
| aDocument anXdFile |
aDocument := Gt2DocumentExamples new documentWithExistingClass.
anXdFile := aDocument saveToXDoc.
ZnBase64Encoder new 
        breakLines;
        encode: anXdFile streamingStrategy bytes 
]]]",,,,,,,,,,,,
E2,,E1 (agree),BlMatrixDecomposition,"I represent a matrix decomposition in components.

For example in case of 2D matrix they are:
        - translation
        - scale
        - rotation angle
        - top left 2x2 minor of original matrix
        
3D (4x4) matrices are decomposed as follows:
        - translation
        - scale
        - skew
        - perspective
        - quaternion",10-113,"""I represent a matrix decomposition in components.",,,,"
For example in case of 2D matrix they are:
	- translation
	- scale
	- rotation angle
	- top left 2x2 minor of original matrix
	
3D (4x4) matrices are decomposed as follows:
	- translation
	- scale
	- skew
	- perspective
	- quaternion""",,,,,,,,,,,,,,,,,
E2,E3 (agree with E1),E1 (disagree),BrGlamorousIcons,"I am a Glamorous icons container. You can import new icons using ${method:name=BrGlamorousIcons class>>#importIconsFromDirectory:}$ using the script below. It imports all ==PNG== files and creates class methods with the same name.

[[[
BrGlamorousIcons importIconsFromDirectory: './gt-icons' asFileReference
]]]

Here is a list of available icons:

${class:BrGlamorousIcons|show=gtIconsFor:|expanded=}$

",10-113,"""I am a Glamorous icons container. ","You can import new icons using ${method:name=BrGlamorousIcons class>>#importIconsFromDirectory:}$ using the script below. It imports all ==PNG== files and creates class methods with the same name.
",,"
Here is a list of available icons:

${class:BrGlamorousIcons|show=gtIconsFor:|expanded=}$",You can import new icons using ${method:name=BrGlamorousIcons class>>#importIconsFromDirectory:}$ using the script below.,,,,,It imports all ==PNG== files and creates class methods with the same name. [[[ BrGlamorousIcons importIconsFromDirectory: './gt-icons' asFileReference ]]],,PNG,,,,,,,,,,
E2,,E1 (disagree),TSpartaCompositeFilter,"I am a composite filter and can have an arbitrary amount of input soures

https://www.w3.org/TR/SVG/filters.html#feCompositeElement

Example:

        ""Merge"" filter primitive is just a composite filter with OVER composion mode.

        merge := canvas compositeFilter
                over;
                source: filter1;
                source:filter2;
                source: filter3;
                source: filter4
                ...",10-113,I am a composite filter and can have an arbitrary amount of input soures,,,,,,"
https://www.w3.org/TR/SVG/filters.html#feCompositeElement

",,,"Example:

        ""Merge"" filter primitive is just a composite filter with OVER composion mode.

        merge := canvas compositeFilter
                over;
                source: filter1;
                source:filter2;
                source: filter3;
                source: filter4
                ...",,,,,https://www.w3.org/TR/SVG/filters.html#feCompositeElement,,,,,,,
E2,,E3 (agree),BlHandlerRegistry,"I am an event handler registry used by dispatchers in order to manage event handlers.

Example:
[[[
| registry |
""one can use announcer based registry""
registry := BlHandlerAnnouncerRegistry new.
""or registry based on plain array""
registry := BlHandlerArrayRegistry new.
registry add: (BlEventHandler on: BlClickEvent do: [ self inform: 'Click' ] ).
registry add: (BlEventHandler on: BlMouseDownEvent do: [ self inform: 'Mouse down' ] ).
registry add: (BlEventHandler on: BlMouseUpEvent do: [ self inform: 'Mouse up' ] ).
registry dispatchEvent: BlClickEvent new.
registry dispatchEvent: BlMouseDownEvent new.
registry dispatchEvent: BlMouseUpEvent new.
]]]",10-113,"""I am an event handler registry used by dispatchers in order to manage event handlers.","""I am an event handler registry used by dispatchers in order to manage event handlers.",,,,,,,,"
Example:
[[[
| registry |
""""one can use announcer based registry""""
registry := BlHandlerAnnouncerRegistry new.
""""or registry based on plain array""""
registry := BlHandlerArrayRegistry new.
registry add: (BlEventHandler on: BlClickEvent do: [ self inform: 'Click' ] ).
registry add: (BlEventHandler on: BlMouseDownEvent do: [ self inform: 'Mouse down' ] ).
registry add: (BlEventHandler on: BlMouseUpEvent do: [ self inform: 'Mouse up' ] ).
registry dispatchEvent: BlClickEvent new.
registry dispatchEvent: BlMouseDownEvent new.
registry dispatchEvent: BlMouseUpEvent new.
]]]""",,,,,,,,,,,,
E2,,E3 (agree),GtRemoteInspector,"GtRemoteInspector provides a mechanism for remote viewing of objects over a REST/JSON API.

Public API and Key Messages

- message one   
- message two 
- (for bonus points) how to create instances.

   One simple example is simply gorgeous.
 
Internal Representation and Key Implementation Points.

    Instance Variables
        namedObjects:                <Object>


    Implementation Points",10-113,,GtRemoteInspector provides a mechanism for remote viewing of objects over a REST/JSON API.,,"
Public API and Key Messages

- message one   
- message two 
- (for bonus points) how to create instances.",,"
 
Internal Representation and Key Implementation Points.

    Instance Variables
        namedObjects:                <Object>

",,,,,,,,,,,,,,,,
E2,,E3 (disagree),BlChildrenSubset,"I capture a subset of children from a ${class:BlElement}$ instance.

I am an abstract class. My subclasses define the actual order and criteria for filtering children and iterating over the set of children.
I exist to explicitly capture and combine various ways of filtering and iterating over children. For example, ${class:BlChildrenReversed}$ indicates that the user wants to explicitly iterate over elements in reverse order; ${class:BlChildrenAccountedByLayout}$ indicates that only should children taken into account by layout should be included. 
The example below shows a scenario of combining multiple ways to iterate over children. By having an explicit object for each operation, the composition of operations can be inspected.
${example:BlChildrenSubsetExamples>>#childrenWithMultipleCombinedSubsets}$

I do not enforce a lazy API. Subclasses can perform the filtering immediately or when iteration over children is required. I aim to maintain the composition of subsets while optimizing for speed whenever possible.

!!API
Instances of me are created by calling the factory method ${method:BlChildrenSubset class>>#on:}$ on a subclass with an instance of ${class:BlChildren}$ as parameter.

Subclasses need to override the method ${method:BlChildrenSubset>>#subsetFrom:}$ to filter the elements from the given ${class:BlChildren}$ instance. This can perform no filtering, filter elements, or also change the order of elements.

!! Implementation details
Internally the result of ${method:BlChildrenSubset>>#subsetFrom:}$ is stored into an instance variable. This result is then used when accessing or iterating over elements. This decision was taken to allow iterators to perform work when the iterator is created and ensure a faster iteration.

To preserve the composition of iterators I hold a reference to the initial ${class:BlChildren}$ instance.",10-113,"

I am an abstract class."," ""I capture a subset of children from a ${class:BlElement}$ instance. 
I exist to explicitly capture and combine various ways of filtering and iterating over children. ",,"!!API
Instances of me are created by calling the factory method ${method:BlChildrenSubset class>>#on:}$ on a subclass with an instance of ${class:BlChildren}$ as parameter.
","!! Implementation details
Internally the result of ${method:BlChildrenSubset>>#subsetFrom:}$ is stored into an instance variable. This result is then used when accessing or iterating over elements. This decision was taken to allow iterators to perform work when the iterator is created and ensure a faster iteration.","
!!API
Instances of me are created by calling the factory method ${method:BlChildrenSubset class>>#on:}$ on a subclass with an instance of ${class:BlChildren}$ as parameter.

To preserve the composition of iterators I hold a reference to the initial ${class:BlChildren}$ instance.""",,"My subclasses define the actual order and criteria for filtering children and iterating over the set of children.  
I do not enforce a lazy API. Subclasses can perform the filtering immediately or when iteration over children is required. I aim to maintain the composition of subsets while optimizing for speed whenever possible.


Subclasses need to override the method ${method:BlChildrenSubset>>#subsetFrom:}$ to filter the elements from the given ${class:BlChildren}$ instance. This can perform no filtering, filter elements, or also change the order of elements.
",,"For example, ${class:BlChildrenReversed}$ indicates that the user wants to explicitly iterate over elements in reverse order; ${class:BlChildrenAccountedByLayout}$ indicates that only should children taken into account by layout should be included. 
The example below shows a scenario of combining multiple ways to iterate over children. By having an explicit object for each operation, the composition of operations can be inspected.
${example:BlChildrenSubsetExamples>>#childrenWithMultipleCombinedSubsets}$",,,,,,,,,,,,
E2,,E3 (agree),BlGridLayoutArc,"I represent an association of span interval, associated value and validity flag.

I am used by grid layout instead of Dictionary of span <-> value key-value pair for performance reasons. 

Internal Representation and Key Implementation Points.

Instance Variables
        span:                <BlGridLayoutInterval>
        valid:                <Boolean>
        value:                <BlGridMutableInteger>",10-113,"""I represent an association of span interval, associated value and validity flag.","
I am used by grid layout instead of Dictionary of span <-> value key-value pair for performance reasons. ",,,,"
Instance Variables
        span:                <BlGridLayoutInterval>
        valid:                <Boolean>
        value:                <BlGridMutableInteger>""",,,,,,,,,,,,,,,,
E2,,E3 (disagree),BlChildrenCollection,"I am an abstract collection of bloc elements that can be mutated. I am used by a ${class:BlElement}$ to store its children.

I provide a data structure independent API for adding and removing children. I assume an index-based way of working with children. My subclasses wrap concrete data structures for storing the actual children. Bloc elements work with children only in terms of the API that I provide. Hence, I only provide a minimum API needed to work with children, instead of the full collection API.

I allow elements to optimize working with children for different scenarious. For example, an array for storing children optimises for accessing fast accesses at any position. A linked list optimize for fast adding and removing. A rope uses a balanced binary tree to support fast adding, removing and accessing, with the disadvantage of taking more memory.

!!API

The following subclasses can be used to store children: 
- ${class:BlChildrenArray}$: stores children using an ${class:Array}$ 
- ${class:BlChildrenLinkedList}$: stores children using a ${class:LinkedList}$  
- ${class:BlChildrenOrderedCollection}$: stores children using a ${class:OrderedCollection}$
- ${class:BlChildrenRope}$: stores children using a ${class:BlCollectionRope}$

Subclasses need to provide the implementation for methods adding and removing children.",10-113,"""I am an abstract collection of bloc elements that can be mutated."," I provide a data structure independent API for adding and removing children. I assume an index-based way of working with children. 

I allow elements to optimize working with children for different scenarious. For example, an array for storing children optimises for accessing fast accesses at any position. A linked list optimize for fast adding and removing. A rope uses a balanced binary tree to support fast adding, removing and accessing, with the disadvantage of taking more memory.
", I am used by a ${class:BlElement}$ to store its children. ,,,,,"My subclasses wrap concrete data structures for storing the actual children. Bloc elements work with children only in terms of the API that I provide. Hence, I only provide a minimum API needed to work with children, instead of the full collection API.

Subclasses need to provide the implementation for methods adding and removing children."" 
!!API

The following subclasses can be used to store children: 
- ${class:BlChildrenArray}$: stores children using an ${class:Array}$ 
- ${class:BlChildrenLinkedList}$: stores children using a ${class:LinkedList}$  
- ${class:BlChildrenOrderedCollection}$: stores children using a ${class:OrderedCollection}$
- ${class:BlChildrenRope}$: stores children using a ${class:BlCollectionRope}$","${class:BlElement}$
${class:BlChildrenArray}$
${class:Array}$ 
${class:BlChildrenLinkedList}$
${class:LinkedList}$
${class:BlChildrenOrderedCollection}$
${class:OrderedCollection}$
${class:BlChildrenRope}$
${class:BlCollectionRope}$",,,,,,,,,,,,,
E3,E2 (agree),,BlElementRemovedEvent,"Is sent by an element after it is removed from the parent.

Note: I am not sent when element is detached!

Example:

[[[
| child parent |

child := BlElement new.
child when: BlElementRemovedEvent do: [ self inform: 'Removed from parent' ].

parent := BlElement new.
parent addChild: child.
parent removeChild: child
]]]",10-113,,,Is sent by an element after it is removed from the parent.,,,,,,,"
Example:

[[[
| child parent |

child := BlElement new.
child when: BlElementRemovedEvent do: [ self inform: 'Removed from parent' ].

parent := BlElement new.
parent addChild: child.
parent removeChild: child
]]]",,,"
Note: I am not sent when element is detached!",,,,,,,,,
E3,E2 (agree),,BlGridLayout,"I layout elements in a rectangular grid.

All children of an element with GridLayout must use GridConstraints that allows users to configure how children are located within grid independently. 

A grid consists of cells that are separated by invisible lines. Each line is assigned to an index, meaning that a grid with N columns would have N+1 line. Indices lie in closed interval [ 1, N + 1 ]. 

Grid Layout supports fitContent, matchParent and exact resizing mode of the owner. Children are allowed to have fitContent and exact resizing modes. Because child's matchParent does not make sense in case of grid users should use #fill to declare that child should take all available cell's space.

By default grid layout does not specify how many columns and rows exist, instead it tries to compute necessary amount of columns or rows depending on amount of children. User can specify amount of columns or rows by sending columnCount: or rowCount: to an instance of grid layout.

Grid Layout supports spacing between cells which can be set sending cellSpacing: message.

Public API and Key Messages

- columnCount: aNumber to specify amount of columns
- rowCount: aNumber to specify amount of rows
- cellSpacing: aNumber to specify spacing between cells
- alignMargins  bounds of each element are extended outwards, according to their margins, before the edges of the resulting rectangle are aligned.
- alignBounds  alignment is made between the edges of each component's raw bounds

   BlGridLayout new
        columnCount: 2;
        rowCount: 3;
        cellSpacing: 10;
        alignMargins
 
Internal Representation and Key Implementation Points.

    Instance Variables
        alignmentMode:                <BlGridAlignmentMode>
        cellSpacing:                <Number>
        horizontalAxis:                <BlGridLayoutAxis>
        lastLayoutParamsHashCode:                <Number>
        orientation:                <BlGridOrientation>
        verticalAxis:                <BlGridLayoutAxis>


    Implementation Points",10-113,,I layout elements in a rectangular grid.,,"Public API and Key Messages

- columnCount: aNumber to specify amount of columns
- rowCount: aNumber to specify amount of rows
- cellSpacing: aNumber to specify spacing between cells
- alignMargins  bounds of each element are extended outwards, according to their margins, before the edges of the resulting rectangle are aligned.
- alignBounds  alignment is made between the edges of each component's raw bounds","
All children of an element with GridLayout must use GridConstraints that allows users to configure how children are located within grid independently. 

A grid consists of cells that are separated by invisible lines. Each line is assigned to an index, meaning that a grid with N columns would have N+1 line. Indices lie in closed interval [ 1, N + 1 ]. 

Grid Layout supports fitContent, matchParent and exact resizing mode of the owner. Children are allowed to have fitContent and exact resizing modes. Because child's matchParent does not make sense in case of grid users should use #fill to declare that child should take all available cell's space.

By default grid layout does not specify how many columns and rows exist, instead it tries to compute necessary amount of columns or rows depending on amount of children. User can specify amount of columns or rows by sending columnCount: or rowCount: to an instance of grid layout.

Grid Layout supports spacing between cells which can be set sending cellSpacing: message.

Internal Representation and Key Implementation Points.

    Implementation Points","    Instance Variables
        alignmentMode:                <BlGridAlignmentMode>
        cellSpacing:                <Number>
        horizontalAxis:                <BlGridLayoutAxis>
        lastLayoutParamsHashCode:                <Number>
        orientation:                <BlGridOrientation>
        verticalAxis:                <BlGridLayoutAxis>",,,GridConstraints,,,,,,,All children of an element with GridLayout must use GridConstraints that allows users to configure how children are located within grid independently. ,,,,,,
E3,E2 (agree),,SpartaCanvas,"! SpartaCanvas
I represent a Sparta canvas and provide an API to perform various drawing operations.
I define an abstract API of Sparta canvas that all concrete implementations must have.

!! Overview
My main responsibility is to create and provide backend specific builders and various objects.

In order to create and perform a drawing operation users should rely on corresponding builder.
For example if one wants to fill a path with a paint she needs to send #fill message to canvas to get a fill builder (painter).

There is a separate builder for every single operation. They can be found in ""api"" protocol.

I'm also responsible for creation of filter primitives (filter types) that are used with ""filter"" operation.
They can be found in ""filters"" protocol.

I am polymorphic with ==SpartaSurface==.

!! Public API and Key Messages

- ==fill== - create a builder of fill drawing operation  
- ==stroke== - create a builder of stroke drawing operation
- ==path== - create a path builder
- ==paint== - create a paint builder (linear, radial gradients)
- ==clip== - create a builder to clip canvas by path (or rectangle)
- ==transform== - create a builder to transform canvas
- ==font== - create a font build helper
- ==text== - create a text rendering builder
- ==filter== - create a builder of filter drawing operation
- ==mask== - create a builder of masking draw operation
- ==bitmap== - create a bitmap factory
- ==shape== - create a common shapes factory (ellipse, rounded rectangle, etc)
- ==filters== - create a common filters factory

- ==extent== - get my size (width@height)
- ==similar:== - to create an empty canvas of size anExtent and of the same type and format 
- ==asForm== - to rasterize myself and return resulting image as Form

''I am an abstract class and should not be instantiated. However, the best way to create an instance of sparta canvas is to send extent: message.''

!! Example:

Create an empty canvas of size 400@250:
[[[language=smalltalk
canvas := SpartaCanvas extent: 400@250.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/01_empty.png|label=emptyCanvas+


Create a triangle vector path:
[[[language=smalltalk
triangle := canvas path
        moveTo: 100@0;
        lineTo: 200@200;
        lineTo: 0@200;
        close;
        finish.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/02_triangle_path.png|label=trianglePath+

Create a linear gradient:
[[[language=smalltalk
linearGradient := canvas paint linearGradient
        begin: 50@100;
        end: 150@200;
        stops: { 0 -> Color red. 1 -> Color blue }.
]]]

Apply translation to place trangle in the center:
[[[language=smalltalk
canvas transform
        push;
        translateBy: 100@25;
        apply.
]]]

Fill previously created path fith linear gradient:
[[[language=smalltalk
canvas fill
        paint: linearGradient;
        path: triangle;
        draw.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/03_fill_path.png|label=fillPath+

Stroke triangle with blue color:
[[[language=smalltalk
canvas stroke
        paint: Color blue;
        path: triangle;
        width: 6;
        draw.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/04_stroke_path.png|label=strokePath+

Restore transformation matrix:
[[[language=smalltalk
canvas transform pop.
]]]

Create a gaussian blur filter:
[[[language=smalltalk
blur := canvas gaussianBlurFilter
        stdDeviation: 4.
]]]

Apply filter on the whole canvas:
[[[language=smalltalk
canvas filter
        area: canvas bounds;
        type: blue;
        draw.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/05_blur.png|label=blur+",10-113,"! SpartaCanvas
I represent a Sparta canvas and provide an API to perform various drawing operations.","I define an abstract API of Sparta canvas that all concrete implementations must have.

!! Overview
My main responsibility is to create and provide backend specific builders and various objects.

In order to create and perform a drawing operation users should rely on corresponding builder.

There is a separate builder for every single operation. They can be found in ""api"" protocol.

I'm also responsible for creation of filter primitives (filter types) that are used with ""filter"" operation.
They can be found in ""filters"" protocol.",I am polymorphic with ==SpartaSurface==.,"!! Public API and Key Messages

- ==fill== - create a builder of fill drawing operation  
- ==stroke== - create a builder of stroke drawing operation
- ==path== - create a path builder
- ==paint== - create a paint builder (linear, radial gradients)
- ==clip== - create a builder to clip canvas by path (or rectangle)
- ==transform== - create a builder to transform canvas
- ==font== - create a font build helper
- ==text== - create a text rendering builder
- ==filter== - create a builder of filter drawing operation
- ==mask== - create a builder of masking draw operation
- ==bitmap== - create a bitmap factory
- ==shape== - create a common shapes factory (ellipse, rounded rectangle, etc)
- ==filters== - create a common filters factory

- ==extent== - get my size (width@height)
- ==similar:== - to create an empty canvas of size anExtent and of the same type and format 
- ==asForm== - to rasterize myself and return resulting image as Form",,,,, ==SpartaSurface==,"
!! Example:

Create an empty canvas of size 400@250:
[[[language=smalltalk
canvas := SpartaCanvas extent: 400@250.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/01_empty.png|label=emptyCanvas+


Create a triangle vector path:
[[[language=smalltalk
triangle := canvas path
        moveTo: 100@0;
        lineTo: 200@200;
        lineTo: 0@200;
        close;
        finish.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/02_triangle_path.png|label=trianglePath+

Create a linear gradient:
[[[language=smalltalk
linearGradient := canvas paint linearGradient
        begin: 50@100;
        end: 150@200;
        stops: { 0 -> Color red. 1 -> Color blue }.
]]]

Apply translation to place trangle in the center:
[[[language=smalltalk
canvas transform
        push;
        translateBy: 100@25;
        apply.
]]]

Fill previously created path fith linear gradient:
[[[language=smalltalk
canvas fill
        paint: linearGradient;
        path: triangle;
        draw.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/03_fill_path.png|label=fillPath+

Stroke triangle with blue color:
[[[language=smalltalk
canvas stroke
        paint: Color blue;
        path: triangle;
        width: 6;
        draw.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/04_stroke_path.png|label=strokePath+

Restore transformation matrix:
[[[language=smalltalk
canvas transform pop.
]]]

Create a gaussian blur filter:
[[[language=smalltalk
blur := canvas gaussianBlurFilter
        stdDeviation: 4.
]]]

Apply filter on the whole canvas:
[[[language=smalltalk
canvas filter
        area: canvas bounds;
        type: blue;
        draw.
]]]
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/05_blur.png|label=blur+",,,"'I am an abstract class and should not be instantiated. However, the best way to create an instance of sparta canvas is to send extent: message.''
",,"
+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/01_empty.png|label=emptyCanvas+

+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/02_triangle_path.png|label=trianglePath+

+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/03_fill_path.png|label=fillPath+

+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/04_stroke_path.png|label=strokePath+

+https://github.com/syrel/Sparta/raw/master/images/SpartaCanvas/05_blur.png|label=blur+",,,,,,,
E3,E2 (agree),,TSpartaPaint,"! TSpartaPaint

I define an API of a Paint. Backend specific paints  should use me and provide concrete implemenations of all my methods.

!! Overview
A paint is transformable and can be used with one of extend modes, for example repeat, reflect or clamp.

I am instantiated by canvas and does not supposed to be created by refering paint class directly.
Sparta canvas provides a paint builder that should be used to build concerete paints.

!! Public API and Key Messages
''I define an api of an abstract paint.''

- ==transformation== - to get current transformation matrix, can not be mil
- ==transformation:== set new paint transformation. If not set, supposed to be identity.
- ==clamp== - do not repeat me
- ==reflect== - mirror the image
- ==repeat== - repeat in both X and Y axis
- ==repeatX== - repeat only X axis
- ==repeatY== - repeat only Y axis
- ==rotateByDegrees:== rotate me by amount of degrees clockwise
- ==rotateByRadians:== rotate me by amount of radians clockwise
- ==scaleBy:== scale me by a factor, a Point or a number.
- ==translateBy:== translate me by a Point or a number
 
!! Internal Representation and Key Implementation Points.

Generally, a Paint is not meant to be an external object, however for additional flexibility I am implemented as a Trait.",10-113,,"! TSpartaPaint

I define an API of a Paint.

!! Overview
A paint is transformable and can be used with one of extend modes, for example repeat, reflect or clamp.","I am instantiated by canvas and does not supposed to be created by refering paint class directly.
Sparta canvas provides a paint builder that should be used to build concerete paints.","!! Public API and Key Messages
''I define an api of an abstract paint.''

- ==transformation== - to get current transformation matrix, can not be mil
- ==transformation:== set new paint transformation. If not set, supposed to be identity.
- ==clamp== - do not repeat me
- ==reflect== - mirror the image
- ==repeat== - repeat in both X and Y axis
- ==repeatX== - repeat only X axis
- ==repeatY== - repeat only Y axis
- ==rotateByDegrees:== rotate me by amount of degrees clockwise
- ==rotateByRadians:== rotate me by amount of radians clockwise
- ==scaleBy:== scale me by a factor, a Point or a number.
- ==translateBy:== translate me by a Point or a number","
!! Internal Representation and Key Implementation Points.

Generally, a Paint is not meant to be an external object, however for additional flexibility I am implemented as a Trait.",,,,,,,,,,,Backend specific paints  should use me and provide concrete implemenations of all my methods.,,,,,,
E3,E2 (agree),,GtLibraryInstaller,"I am the installer of shared libraries along side image or vm.
I should be configured by the user for a specific library.

The following example shows how I am configured for Sparta/Moz2D library.

[[[
| installer |
installer := GtLibraryInstaller new.
installer library: 'Moz2D'.
installer version: 'development'.
installer binary: 'libMoz2D'.
installer url: 'https://dl.feenk.com/{library}/{platform}/{version}/{arch}/{binary}.{extension}'.
installer running: [ MozServices isRunning ].
installer works: [ MozLibrary uniqueInstance hasModule ].
installer postInstall: [ MozServices start ].
]]]",10-113,I am the installer of shared libraries along side image or vm.,,,,,,,,,"
The following example shows how I am configured for Sparta/Moz2D library.

[[[
| installer |
installer := GtLibraryInstaller new.
installer library: 'Moz2D'.
installer version: 'development'.
installer binary: 'libMoz2D'.
installer url: 'https://dl.feenk.com/{library}/{platform}/{version}/{arch}/{binary}.{extension}'.
installer running: [ MozServices isRunning ].
installer works: [ MozLibrary uniqueInstance hasModule ].
installer postInstall: [ MozServices start ].
]]]",,,,,,I should be configured by the user for a specific library.,,,,,,
E3,,E1 (agree),GtDiagrammerPicker,"I am a scriptable toogle group to display a uniform collection of selectable values.

[[[
| picker |
picker := GtDiagrammerPicker new.
picker layout: BlFlowLayout horizontal.
picker display: [ { 'Hello' . 'World' . 'I' . 'am' . 'a' . 'picker' } ].
picker shape: [ :aString | BrToggle new
        look: BrMaterialToggleLabelledLook;
        margin: (BlInsets all: 3);
        label: aString ].
picker constraintsDo: [ :c |
        c horizontal exact: 400.
        c vertical fitContent ].
picker when: BrToggleActivatedEvent do: [ :anEvent | self inform: anEvent model ].
picker
]]]",10-113,I am a scriptable toogle group to display a uniform collection of selectable values.,,,,,,,,,"
[[[
| picker |
picker := GtDiagrammerPicker new.
picker layout: BlFlowLayout horizontal.
picker display: [ { 'Hello' . 'World' . 'I' . 'am' . 'a' . 'picker' } ].
picker shape: [ :aString | BrToggle new
        look: BrMaterialToggleLabelledLook;
        margin: (BlInsets all: 3);
        label: aString ].
picker constraintsDo: [ :c |
        c horizontal exact: 400.
        c vertical fitContent ].
picker when: BrToggleActivatedEvent do: [ :anEvent | self inform: anEvent model ].
picker
]]]",,,,,,,,,,,,
E3,,E1 (disagree),BlRectangleShapeWithArrowExplanation,"! Rectangle geometry with arrow pointer

The goal of this tutorial is to create an element with an arrow-like pointer in the middle of the top edge, as shown below:
${example:BlRectangleShapeWithArrowExplanation>>#elementWithTopArrowGeometry|noCode|previewShow=gtLiveFor:|previewHeight=250}$

A traditional way to implement such geometry is to create a subclass of ${class:BlGeometry}$,  override ${method:BlGeometry>>#buildPathOnSpartaCanvas:}$ and implement quite cumbersome algorithm that computes the location of each point and then connects those points using ==moveTo:== and ==lineTo:== commands provided by ==PathBuilder==. The problem with such solution is its exponential increase in compolexity each time we would like to parametrize and customize the resulting geometry, for example the size of the arrow or its horizontal position. Even more compex would be to implement the support for positioning the arrow on different edges (e.g. left, bottom) or an ability to have multiple arrows on separate edges.

This is where a ${class:BlVectorShape}$ comes-in handy.

!! Creating a rectangle shape

We will start with creation of the rectangle shape ${class:BlRectangleShape}$:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleShape|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Translating the top edge

In order to give the arrow pointing up enough space we should move the top edge of the rectangle down by the length of the arrow. First of all we should ask the rectangle shape to give us its top edge ${method:BlRectangleShape>>#topEdge}$. By default the ==topEdge== of the rectangle is an instance of ${class:BlLineShape}$ which can be translated by sending ${method:BlLineShape>>#moveBy:}$ to the ==topEdge==:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTranslatedTopEdge|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Injecting a line inside of the top edge

Next step on our way to the arrow is to inject a line segment equal to the length of the arrow in the middle of the ==topEdge==. It can be done by sending ${method:BlLineShape>>#injectLineAt:length:}$ to the ==topEdge==. Since we want to inject a line right in the middle of the edge we pass ==0.5== as a line location:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTopInjectedLine|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Splitting the injected line

We are almost ready to create a rectangular arrow. We just need to split an injected line in half in order to create the top corner of the rectangle. We can do so by sending a ${method:BlLineShape>>#splitAt:}$ to the now middle section of the ==topEdge== which was created by the previous line injection step:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTopPolylineSplitInHalf|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Moving the top of the triangle

Once we have everything we need for the arrow triangle we can move it's top up by the length of the arrow. To do so we should send ${method:BlPointShape>>#moveBy:}$ to the connection point of the splitted line in the middle of the ==topEdge==. After doing so we receive the expected vector shape we we can later use together with ${class:BlShapeGeometry}$:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTopArrow|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$",10-113,,,,,,,,," ${class:BlGeometry}$
 ==PathBuilder==
${class:BlVectorShape}$
${class:BlRectangleShape}$
${class:BlLineShape}$
${class:BlShapeGeometry}$","! Rectangle geometry with arrow pointer

The goal of this tutorial is to create an element with an arrow-like pointer in the middle of the top edge, as shown below:
${example:BlRectangleShapeWithArrowExplanation>>#elementWithTopArrowGeometry|noCode|previewShow=gtLiveFor:|previewHeight=250}$

A traditional way to implement such geometry is to create a subclass of ${class:BlGeometry}$,  override ${method:BlGeometry>>#buildPathOnSpartaCanvas:}$ and implement quite cumbersome algorithm that computes the location of each point and then connects those points using ==moveTo:== and ==lineTo:== commands provided by ==PathBuilder==. The problem with such solution is its exponential increase in compolexity each time we would like to parametrize and customize the resulting geometry, for example the size of the arrow or its horizontal position. Even more compex would be to implement the support for positioning the arrow on different edges (e.g. left, bottom) or an ability to have multiple arrows on separate edges.

This is where a ${class:BlVectorShape}$ comes-in handy.

!! Creating a rectangle shape

We will start with creation of the rectangle shape ${class:BlRectangleShape}$:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleShape|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Translating the top edge

In order to give the arrow pointing up enough space we should move the top edge of the rectangle down by the length of the arrow. First of all we should ask the rectangle shape to give us its top edge ${method:BlRectangleShape>>#topEdge}$. By default the ==topEdge== of the rectangle is an instance of ${class:BlLineShape}$ which can be translated by sending ${method:BlLineShape>>#moveBy:}$ to the ==topEdge==:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTranslatedTopEdge|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Injecting a line inside of the top edge

Next step on our way to the arrow is to inject a line segment equal to the length of the arrow in the middle of the ==topEdge==. It can be done by sending ${method:BlLineShape>>#injectLineAt:length:}$ to the ==topEdge==. Since we want to inject a line right in the middle of the edge we pass ==0.5== as a line location:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTopInjectedLine|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Splitting the injected line

We are almost ready to create a rectangular arrow. We just need to split an injected line in half in order to create the top corner of the rectangle. We can do so by sending a ${method:BlLineShape>>#splitAt:}$ to the now middle section of the ==topEdge== which was created by the previous line injection step:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTopPolylineSplitInHalf|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$

!! Moving the top of the triangle

Once we have everything we need for the arrow triangle we can move it's top up by the length of the arrow. To do so we should send ${method:BlPointShape>>#moveBy:}$ to the connection point of the splitted line in the middle of the ==topEdge==. After doing so we receive the expected vector shape we we can later use together with ${class:BlShapeGeometry}$:
${example:BlRectangleShapeWithArrowExplanation>>#rectangleWithTopArrow|previewShow=#gtLiveFor:|previewExpanded=true|previewHeight=250}$",,,,,,,,,,,,
E3,,E1 (disagree),BlLayout,"!Bloc layout
I am the superclass for layouts in Bloc and I define the API that a concrete layout needs to implement.

I am attached to a bloc element and define the visual structure of that bloc element. Tipically this includes the position of child elements within the parent, or the size of the parent element. 

!!Layout constraints
I support a set of attributes (refered to as constraints in Bloc) which define the visual properties of the layout. A small set of constraints, like padding, margin or minimal and maximum dimensions, are common among all the layouts. Each layout has a dedicated constraint objects, instance of ${class:BlLayoutCommonConstraints}$, that contain these common constraints. Each type of layout can further define its own specific constraints by creating a subclass of ${class:BlLayoutConstraints}$. 

TODO: constraints API

!!Layout phase in a frame
Layouting of elements is a phase executed by a space during every frame. 

Every frame, the space goes through several phases (${method:BlSpaceFrame>>#initializePhases}$). Phases are modeled as subclasses of ${class:BlSpaceFramePhase}$ and are executed once per frame. One of them, ${class:BlSpaceFrameLayoutPhase}$, consists in layouting the elements contained in the space. This is done after events and tasks have been executed, but before the drawing phase.

Layouting should to be executed during a frame when various properties like, width, height or position change in any element contained by the space. However, an important aspect in Bloc, is that when one of these properties changes, layouting is not performed immediately. Instead, a layout request is issued by the element whose property changed using the message ${method:BlElement>>#requestLayout:}$. This has the advantage that if no element request layout, this phase can be skipped. Also it does not matter if layout is requeste one or 1000 time; only one layout phase is performed improving performance. 

Hence, in Bloc layout is not executed immediately after a property like the width of an element changes. Instead layout is requested and perfomed, if needed, during every frame. When needing to test layouts, however, it is necessary to apply a layout immediately, instead of waiting for a frame to end. That can be done using the messafe ${method:BlElement>>#forceLayout}$; this should not be used outside of tests, as it bypasses the normal layouting system from Bloc.

In a space where all elements have no event handlers for layout events, elements are going to be layouted exactly once during the layouting phase. However, often elements need to reach and perform actions, when for example their position or extent changes. They can react by requesting another layout. A tipical example is deadling with edges. An edge can be layouted only after the position of the elements that it connects is known. Hence, often the layout needs to be applied twice, or more, during the layouting phase. The space only allows layout requests during the layouting phase a limited number of times (${method:BlSpace>>#computeLayout}$) to avoid blocking rendering due to infinite recursions caused by layout requests, or void spending too much time on layouts in a frame. More technical details can be found in the method ${method:BlSpace>>#doLayout}$, the main entry point for executing the layout phase in a space.

!!Performing a layout
The space starts the layouting process on the root element of that space. Performing the layout on an element consists in executing three main steps:
        - measuring bounds: determine the bounds of the element according to its layout;
        - applying the layout: determine the position of children within the element;
        - commiting changes: raise layout events like position or extent changed.

TODO: why three separate steps?

!!!Measuring bounds
This is the first step when performing a layout on an element and consists in determening the measured bounds of that element. 

Each element can decide how it wants to be measured (${method:BlElement>>#onMeasure:}$). By default ${class:BlElement}$ delegates the measuring to its layout. Layouts should override ${method:BlLayout>>#measure:with:}$ to implement the actual measuring. Normally layouts follow a top to bottom approach: they measure the current element and then asks its children to do the measuring.

Each element has real bounds (${BlElement>>#bounds}$) and measured bounds (${BlElement>>#measuredBounds}$). The real bounds contain the actual position and extent of an element that users of that element should rely on. The measured bounds are used during layouting to hold the new extent of an element. The measuring phase changes only the extent in the measured bounds. After the entire layout phase is completed the real bounds and measured bounds will have the same value. The measured bounds act like a temporary cache for the new bounds of an element. They were introduced to avoid changing the real extent of element while layouting of children is still being performed. 

(TODO: explain why position is sometime changed in the measured bounds)

!!!Applying the layout

!!!Commiting changes

TODO
        - Space starts the measurement process from the root element; after measurement it tell children to measure themselves, etc
        - measurement; top to bottom though all the composition of elements.
                - this step find the size of an element and sets measuredExtent (or position sometimes)
        - space starts the layout step
                - as we know the size of each child we compute the actual position for each child
                - changes the real extent to measured extent and the real position to the computed layout position
        - Elements announce events for position and extent changed
        
        Without event handlers the layout process is going to happen only once.
        For example when nodes change the position edges should be updated.
        
!!Layout events

TODO

!!Layout API
I define an api of a layout. Concrete implementations should focus on measure:with: and layout:in:",10-113,"!Bloc layout
I am the superclass for layouts in Bloc and I define the API that a concrete layout needs to implement.","I am attached to a bloc element and define the visual structure of that bloc element. Tipically this includes the position of child elements within the parent, or the size of the parent element.I support a set of attributes (refered to as constraints in Bloc) which define the visual properties of the layout","I am attached to a bloc element and define the visual structure of that bloc element. Tipically this includes the position of child elements within the parent, or the size of the parent element. ",I define an api of a layout. Concrete implementations should focus on measure:with: and layout:in:,"
!!Layout constraints
I support a set of attributes (refered to as constraints in Bloc) which define the visual properties of the layout. A small set of constraints, like padding, margin or minimal and maximum dimensions, are common among all the layouts. Each layout has a dedicated constraint objects, instance of ${class:BlLayoutCommonConstraints}$, that contain these common constraints. Each type of layout can further define its own specific constraints by creating a subclass of ${class:BlLayoutConstraints}$. 

TODO: constraints API

!!Layout phase in a frame
Layouting of elements is a phase executed by a space during every frame. 

Every frame, the space goes through several phases (${method:BlSpaceFrame>>#initializePhases}$). Phases are modeled as subclasses of ${class:BlSpaceFramePhase}$ and are executed once per frame. One of them, ${class:BlSpaceFrameLayoutPhase}$, consists in layouting the elements contained in the space. This is done after events and tasks have been executed, but before the drawing phase.

Layouting should to be executed during a frame when various properties like, width, height or position change in any element contained by the space. However, an important aspect in Bloc, is that when one of these properties changes, layouting is not performed immediately. Instead, a layout request is issued by the element whose property changed using the message ${method:BlElement>>#requestLayout:}$. This has the advantage that if no element request layout, this phase can be skipped. Also it does not matter if layout is requeste one or 1000 time; only one layout phase is performed improving performance. 

Hence, in Bloc layout is not executed immediately after a property like the width of an element changes. Instead layout is requested and perfomed, if needed, during every frame. When needing to test layouts, however, it is necessary to apply a layout immediately, instead of waiting for a frame to end. That can be done using the messafe ${method:BlElement>>#forceLayout}$; this should not be used outside of tests, as it bypasses the normal layouting system from Bloc.

In a space where all elements have no event handlers for layout events, elements are going to be layouted exactly once during the layouting phase. However, often elements need to reach and perform actions, when for example their position or extent changes. They can react by requesting another layout. A tipical example is deadling with edges. An edge can be layouted only after the position of the elements that it connects is known. Hence, often the layout needs to be applied twice, or more, during the layouting phase. The space only allows layout requests during the layouting phase a limited number of times (${method:BlSpace>>#computeLayout}$) to avoid blocking rendering due to infinite recursions caused by layout requests, or void spending too much time on layouts in a frame. More technical details can be found in the method ${method:BlSpace>>#doLayout}$, the main entry point for executing the layout phase in a space.

!!Performing a layout
The space starts the layouting process on the root element of that space. Performing the layout on an element consists in executing three main steps:
        - measuring bounds: determine the bounds of the element according to its layout;
        - applying the layout: determine the position of children within the element;
        - commiting changes: raise layout events like position or extent changed.

TODO: why three separate steps?

!!!Measuring bounds
This is the first step when performing a layout on an element and consists in determening the measured bounds of that element. 

Each element can decide how it wants to be measured (${method:BlElement>>#onMeasure:}$). By default ${class:BlElement}$ delegates the measuring to its layout. Layouts should override ${method:BlLayout>>#measure:with:}$ to implement the actual measuring. Normally layouts follow a top to bottom approach: they measure the current element and then asks its children to do the measuring.

Each element has real bounds (${BlElement>>#bounds}$) and measured bounds (${BlElement>>#measuredBounds}$). The real bounds contain the actual position and extent of an element that users of that element should rely on. The measured bounds are used during layouting to hold the new extent of an element. The measuring phase changes only the extent in the measured bounds. After the entire layout phase is completed the real bounds and measured bounds will have the same value. The measured bounds act like a temporary cache for the new bounds of an element. They were introduced to avoid changing the real extent of element while layouting of children is still being performed. 

(TODO: explain why position is sometime changed in the measured bounds)

!!!Applying the layout

!!!Commiting changes

TODO
        - Space starts the measurement process from the root element; after measurement it tell children to measure themselves, etc
        - measurement; top to bottom though all the composition of elements.
                - this step find the size of an element and sets measuredExtent (or position sometimes)
        - space starts the layout step
                - as we know the size of each child we compute the actual position for each child
                - changes the real extent to measured extent and the real position to the computed layout position
        - Elements announce events for position and extent changed
        
        Without event handlers the layout process is going to happen only once.
        For example when nodes change the position edges should be updated.
        
!!Layout events

TODO

!!Layout API
I define an api of a layout. Concrete implementations should focus on measure:with: and layout:in:",,"More technical details can be found in the method ${method:BlSpace>>#doLayout}$, the main entry point for executing the layout phase in a space.","Phases are modeled as subclasses of ${class:BlSpaceFramePhase}$ and are executed once per frame. One of them, ${class:BlSpaceFrameLayoutPhase}$, consists in layouting the elements contained in the space. This is done after events and tasks have been executed, but before the drawing phase.",,,"
TODO: constraints API
TODO
        - Space starts the measurement process from the root element; after measurement it tell children to measure themselves, etc
        - measurement; top to bottom though all the composition of elements.
                - this step find the size of an element and sets measuredExtent (or position sometimes)
        - space starts the layout step
                - as we know the size of each child we compute the actual position for each child
                - changes the real extent to measured extent and the real position to the computed layout position
        - Elements announce events for position and extent changed
        
        Without event handlers the layout process is going to happen only once.
        For example when nodes change the position edges should be updated.
        
!!Layout events

TODO

!!Layout API
I define an api of a layout. Concrete implementations should focus on measure:with: and layout:in:",,"However, an important aspect in Bloc, is that when one of these properties changes, layouting is not performed immediately. this should not be used outside of tests, as it bypasses the normal layouting system from Bloc.",,,,,,"This is done after events and tasks have been executed, but before the drawing phase.
Layouting should to be executed during a frame when various properties like, width, height or position change in any element contained by the space. However, an important aspect in Bloc, is that when one of these properties changes, layouting is not performed immediately. ",,,